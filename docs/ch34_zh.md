第 34章 拾 遗
值得注意的是，这里是UML
这里缺少了交互器，以及跨
边界调用时对应的数据编码解码对象。
269架构整洁之道
按组件封装
虽然我对本书中的SOLID. REP、CCP、CRP以及其他大部分建议完全认同， 
我想提出对代码组织方式的-个不同看法----“按组件封装” °「些背景信息：在
我的职业生涯中，我基于Java构建了大量不同领域的企业软件，这些软件系统要求 各异。大部分系统都是基于Web的，也有一些是CS架构J 或者是分布式架构的、 基于消息的,.或者其他的。虽然具体采用的技术不同，但大部分系统都是基于传统 
的分层架构的。
我已经给出一些分层架构不好的理由，但这还不是全部。分层架构设计的目的 
是将功能相似的代码进行分组。处理Web的代码应该与处理业务逻辑的代码分开, 同时也与处理数据访问的代码分开。正如我们在UML类图中所见，从实现角度讲， 
层就是代表了 Java包。从代码可访问性角度来讲，如果需要0rd ersC o n tro ller 
依赖O rderS ervice接口，那么这个接口必须设置为p u b lic ,因为它们在不同的 包中。同样的，O rd ersR ep o sito ry 接口也需要设置为p u b l i c ,这样才能被包 夕卜的类 O rd ersS ervicelm ple 使用。
在严格分层的架构中，依赖指向的箭头应该永远向下，每一层只能依赖相邻的
下一层。通过引入一些代码互相依赖的规则，我们就形成了一个干净、漂亮的单向
依赖图。这里有一个大问题 
以形成漂亮的单向依赖图。
只要通过引入一些不应该有的依赖来作弊，依然可
假设新员工加入了团队，你给新人安排了一个订单相关的业务用例的实现任务。
由于这个人刚刚入职，他想好好表现，尽快完成这项功能。粗略看过代码之后，新
人发现了 O rd ersC o n tro ller这个类，于是他将新的订单相关的Web代码都塞了 进去。但是这段代码需更从数据库查找一些订单数据。这时候这个新人灵机一动：
1 我 1996年大学毕业之后,第一份匸作就是Mj PowerBuilder构造一个客户端-服务器架构的桌面应用。 PowerBuilder是一个超级好用的4GL组件，十分适合构造基于数据库的应用。而几年之后，在另外一 个项目里，我需要门C创建数据库链接器（这时候jdbc还没有被发明），以及用AWT构造自己的 UI组件。这就是所谓的时代进步！ '
厶 ・ ・ “ 「一,・ ・• , •• •一 ___ . ■
270第34章 拾 遺
“代码己经有了 •个OrdersRepository接口 1 
制器就行，我真机智！”几分钟之后， 、 ' 
图34.5这样。
｛需要将它用依赖注入框架引入控 
功能已经匸常了,但是um l结构图变成了
图34.5：宽松的分层架构架构整洁之道
依赖“ 箭头依然向F 粗是现在0皿 曲 8 肚 ：。十 ：豎警况下绕过了 
O rderService类。这种组织形式被称为宽松的分层采构，允叶某二层跳过直接相 邻的邻居。在彳肥情况下，这是意料之中的— 例如’如果我们在遵循CQRS设计 
模疋，这是合理的。但是更多的情况下，绕过业务逻辑层是不合理的，尤其是在业 
务逻辑层要控制权限的情况下。
虽然新的业务用例可以正常工作，但是它可能不是按照合理方式实现的。作为
咨询师，我曾经见过很多团队出现这种情况，只有他们开始仔细观察自己的代码结 
构图时才会发现。
这里我们有的其实只是一个规范—— 一个架构设计原则 内容是“Web控制 器永远不应该直接访问数据层”。这里的核心问题当然是如何强制执行。我遇见的 
很多团队仅仅通过采用“自律”或者“代码评审”方式来执行， “我相信我的程序 
员”。有这种自信当然很好，但是我们都知道当预算缩减、工期临近的时候会发生 
什么事情。
有一小部分团队告诉我，他们会采用静态分析工具（例如Ndepend>StructurelOl>
Checkstyle）来在构建阶段自动检查违反架构设计规则的代码。估计你见过这种代码,
一般来说就是一段正则表达式，例如“包**/w eb下面的类型不允许访问**/data 下面的类型”，这些检查在编译步骤之后执行。
这种方式虽然简单粗暴，但是确实能起效果，可以锁定违反了团队定义的系统 
架构设计原则的情况，并且（理想情况下）导致构建失败。这两种方法的共同问题 
是容易出错，同时反馈循环时间太长了。如果不精心维护，整个代码库可能很快就 
变成“一团泥巴” \ 我个人更倾向选择能够让编译器执法的做法。
那么，看 -卜“按组件封装”的做法。这种做法混合了我们之前讲的所有的方
法，冃标是将一个粗粒度组件相关的所有类放入_个java包中。这就像是以_ 种面 向服务的视角来构建软件系统， 
将 Web视为一种交付手段一样,
与微服务架构类似。这里，就像端口和适配器模式
“按组件封装”将 U1与粗粒度组件分离。图346
1 在命令查询责任分离设计模式中，更新和读取数据的模式是不同的。
2 参见 http://www.laputan.Org/mud/o °展示了 “查看订单”这个用例的设计图。
图34.6： “查看订单”业务用例
总的来说，这种方式将“业务逻辑”与 “持久化代码”合并在一起, 
件” ，Bob大叔在本书中对"组件"的定义如卜：架构整洁之道
组件是部署单元 组件是系统中能够部署的扳小皆乂，对应在Java里
就是jar文件° 我对组件的定义稍有不同： “在一个执行环境（应川程序）中的、一个干净、 
良好的接口背后的一系列相关功能的集合”。这个定义来自我的“C4软件架构模 
型" 这个模里以一种层级模型讨论软件系统的静态结构，其中的概念包括容器、 
细件、类。这个模型认为，系统由一个或者多个容器组成（例 如 W eb应用、移动 App、独立应用、数据库、文件系统），每个容器包含一个或多个组件，每个组件 由一个或多个类组成。每个组件具体存在于哪个jar文件中则是另外一个维度的事情。 这种“按组件封装”的方式的一个好处是，如果我们需要编写和订单有关的代 
码，只有一个位置需要修改 O rdersCom poneto在这个组件中，仍然应该关注 重点隔离原则，但这是组件内部|可题, 使用者不需要关心。这就有点像采用微服务
架构，或者是面向服务架构的结果—— 独立的O rd e rse rv ic e 会将所有订单相关的 
东西封装起来。这里关键的区别是解耦的方式。我们可以认为，单体程序中的一个 
良好定义的组件，是微服务化架构的一个前提条件。
具体实现细节中的陷阱
表面上看，四种代码组织方式各不相同，可以认为是不同的架构设计风格。可 
是，如果具体实现中不严加注意，很快就会出现偏差。
我经常遇到的一个问题是，Java中p u b lic 访问控制修饰符的滥用。我们作为 程序员，好像天生就喜欢使用严“ 让关键词。这就好像是肌肉记忆一样。如果不 
信，请看一下各种书籍的代码示范、各种入门教程，以及GitHub上的开源框架。这 个趋势是显而易见的，不管采用了哪种系统架构风格。
将肋旳的类都设置为p u b lic 意味着就无法利用编程语言提供的封装手段。这 鳥 ;架 囂 篇 :畀 以 阻 碍 某 人 写 一 段 直 接 初 始 化 具 体 实 现 类 的 代 码 '哪 怕 它
1 参见 https://www.structurizr.com/help/c4°第 34章 拾 遗
组织形式与封装的区别
I I
如 果 咖 味 険 序中的所有类型都设
比 干 疋 . * " 丫 式 了 （类似文件夹一样的分组 丿 川 八 佃 化 种 封 装 
瓷 ： 詈 丁 类 型可以在代码库的任何位置调用，我们忙灯•就町以忽略包
的概尼、，因为匕严不提供什么价值。最终，如果忽视包的概念W 、丿并不起到任何 
封装和隐藏的功能），那么想要采用的任何架构风格就都不重要了。我们回过头来 
看「下例子中的UM L图，如果所有的类型都是p u b lic ,那么Java包就成了一个 无关紧要的细节信息。于是，所有四种架构方式事实上并没有任何区别（参见图34.7）。
我们再详细看一下图34.7中各个类之间的箭头：不论采用哪种架构设计风格, 
它们的指向都是一致的。虽然概念不同，但是语法上都是一致的。更进一步说，如 
果所有的类都是p u b lic 的，那么其实我们就是在用四种不同的方式描述一个传统 的分层架构设计方式。你会说当然没有人会将所有的Java类都设置为p u b lic ,但 是相信我，我见过。
OrdersController OrderaController Order8Controller OrdersController
7 呼
« u s 吟
« u s e s »
v<in te rfa c e » OrdorsService
丄 — ■
O rdert8ervlcelm pl
I
*
« jn te ria c e » OrdersServic*
I----------------------------
OrdersServIcelmpI
« U 6 6 8 »
«uses>>
OrdereServIcelmpI
i
I
« jn te rta c e » OrctocsComponent
L
Occter^ComponentimpI
« u s e s »
« jn l6 rfa c e »
« in l6 r fa c e » OrdersRepository
JdbcOrder<R^Pu M ,lo ry
«in tertace» OrcteraFtoposItory
— s
I
JdbcOrderoRepoflitory
图 34.7：
JdbcOrctersReposHory
jdbcOrdM«B<P°fi,t , ，v
275架构整洁之道
虽然Java中的访问修饰符并不完美- 但是忽略它们的存存-就疋在自找麻烦oJava 类与包的组织形式其实可以很大程度决疋这个类的可访问性（或者不可访问性）。 
如果我们将包的概念引入这幅图，同时标记（虚化的形式展示）应用到访问控制符 
的地方，这个图就很有意思了（参见图34.8） o
从左向右，在 “按层封装”方式中，O rd e rS e rv ic e 与 OrderRepository 
需 要 p u b lic 修饰符，因为包外的类需要依赖它 们 。然 而 ，具体实现类 
（O rd erServicelm p l 和 JdbcO rder'sR epositox'y）则口J 以设置更细致的访冋权
限 （包范围内的protected） 。不需要有人依赖它们，它们是具体的实现细节。
O rdersC ontroller O rdersC ontroiler
I
mycompajiy.myapp.web
△
-1—
O rdersCom ponentlm pI
com.myoompany.myapp.domain
JdbcO rdersR epository
com • m ycompan y. myapp .ofde rs
i
com. mycompa^y. myapp. web
« u s e s »
Orders Control ler
1
com. mycom y. myapp. we b
« u s e s »
« in te rfa c e » OrdersService
△
OrdersServicelmpI
— 厂
i com.mycornpany.rnyapp service
I
«inte<1ace» OrdersRepository
A
丄
JdbcO rdersRepository
com. my company, myapp. data
« u s e s »
O rdersCom ponent
mycompany.myapp.databas^
« u s e s »
图34.8：带有访问修饰符的类型被虚化了
存一 “按功能封装”模式中，O rd e rsC o n tro lle r是整个包的入口，所以其他 的类都可以设置为包范围内的protected□ 这里的一个问题是，代码库中的其他代码 都必须通过控制器才能访问订单信息— 这可能是好处，也可能是坏处，视实际情
三I
1 霭 釁 豐 何 露 薜 需 囂 囂 囂 需 蟲 : 的 ’但是其实我们并不能控制包和子包之间的
276----- - ---- —-----... 第3 4 章 拾遗
况而定。
在端口与适配器模式中，0“ 1卄 9 • .
囂囂严5 样同心爲观寫囂豊
、取口' 土 / 、 封 装 模 式 OrdersCom ponet接口有来自Controller的依 赖关系，但疋其他类都可以设置为包pgected。P u b lic类型越少，潜在的依赖关 系就越少。现在包外代码就不能再直接使用O rdersR epository接口或者具对应 
的实现1 ,我们就可以利用编译器来维护架构设计原则了。在.Net语言中，我们可以 用 in te r n a l关键词达到一样的目的，然而我们需要给每个组件创建一个单独的 
assembly o
再澄清一点，这里描述的全都和单体程序有关，所有代码都存放在同一个代码 
树下。如果你在构建这种程序（大部分程序都是如此），那么我强烈建议利用编译 
器来维护架构设计原理，而不要依赖个人自律和编译过程之后的工具。
其他的解耦合模式
眸绘程i五吉白带的工具之外，通常还有其他方式可以进一步解耦源代码级别的 依赖关系。2 ；va语言中，'有模块化框架°SGi，以及最新的呎9 模块系统。正 露 囂 块 :统 ，我 们 可 以 进 -步 区 分 呻 i c 类型和对外发布的类型。例 如 我 们可以创建-个。寫 m 将 霊 翥 囂 爲 夬 囂 豎 提 爲
另外-个选择是将代码分散到不同的代码树中’以从源代码级咧依赖关系。 
以端口和适配器方式为例，我们会有二个代码树；
1 除非你用Java的反射机制作弊一 请别这么十!架构整洁之道
• 业 务 代 码 （所 有 技 术 和 框 架 无 关 的 代 码 ） ： O r d e r s s e r v i ^ .
Orde r Ser v ice Imp 1 以及 O rders o • Web源代码：O rdersC on"。丄丄丸。 • 持久化源代码：JdbcO rdersR epositoryo
后面两个源代码树对业务代码有编译期依赖关系，而业务代码则对Web和数据 持久毫无所知。从实现角度来看，我们可以通过将这些代码在构建工具中组织成不 
同的模块或者项目（例如Maven> Gradle> MSBUILD等）来达到目的。理想情况下， 
我们可以用这种模式将所有组件都划分成不同的项目。
然而，这有点太理想化了，因为拆分代码库经常会带来性能、复杂度和维护性 
方面的问题。
有些人采用一个稍微简单的组织方式，仅使用两个代码树：
• 业 务 （Domain）代 码 （内部）
• 基础设施（Infrastructure）代 码 （外部）
!1!
这与图34.9完美对应，很多人都用这个方式来简化对端口和适配器架构的描述。
基础设施部分对业务代码有一个编译期的依赖关系。
278第34章拾遗
颠 为 駕 g 与适［'囂 囂 ;::勺 ’们是加変帥外7#意随Z 闻來的问题。我称这个问 豎 p 罟 驚 式 芒 勺 呗 阿 皿 模 式 ” M g ＜仙形公路，名 ::前 ；；屮£；臨 爲 ^ 、大道允r「"I；辆环绕巴舉山皿：吐沙灿人市y , 同样的，将 豊 瓷 础 设 施 豎 放 在 同 —个源代码树中，就右可能使得应用中—个 
设施代」 Web控制器）直接调用另外-个区域的代码（数据库访问八而不经过 领域代码。如果没有设置正确的访问修饰符，就更是如此「
本章小结：本书拾遗
这一章的中心思想就是，如果不考虑具体实现细节，再好的设计也无法长久。 
必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运 
行期采用哪种解耦合的模式。保持开放，但是一定要务实，同时要考虑到团队的大 
小、技术水平，以及对应的时间和预算限制。最好能利用编译器来维护所选的系统 
架构设计风格，小心防范来自其他地方的耦合模式，例如数据结构。所有的实现细 
节都是关键的！