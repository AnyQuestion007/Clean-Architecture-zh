第 22章
整洁架构架构整洁之道
在过去的几「年屮，我们曽讪过■系列关于系统架构的想法被提卜H,歹
Fo
■ ^边 形 架 构 （Hexagonal Architecture!（也称力冰丨加配器架构，卩叫 
Adpatcrs）: 该架构山 Alistair Cockburn 首先捉出 “ S tev e "ccman 和 
在他们合写的替作Growing Object ONentedS冲 wa比 with Tests •书中对;:I 构做了隆重的推荐。 I
• DCI 架构:由 James Coplien 和 Trygve Reenskaug [ f 先提出。 I
• BCE 架构：由 Ivar Jacobson 在他的 Object Oriented Software Engineer^ . 
' 彳 I
Use-Case Driven Approach 一书中首先提岀。 虽然这些架构在细节上各有不同，但总体来说是非常相似的。它们都具有同， 
个设计目标：按照不同关注点对软件进行切割。也就是说，这些架构都会将软件初 
割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口 
贝!J属于其他层。
按照这些架构设计岀来的系统，通常都具有以下特点。
• 独立于框架:这些系统的架构并不依赖某个功能丰富的框架之中的某个函叢 
框架可以被当成工具来使用，但不需要让系统来适应框架。
• 可被测试••这些系统的业务逻辑可以脱离UI、数据库、Web服务以及其也 的外部元素来进行测试。
• 独立于UI ••这些系统的UI变更起来很容剔不需要修改其他的系统部分。 
例如，我们可以在不修改业务逻辑的前提下将一个系统的U I由Web界面替! 换成命令行界面。
• 独立于数据库：我们可以轻易将这些系统使用的6 a d e 、SQL Server f 囂 篇 了 鬻 * s t d b 之类的数据库。因为业务逻辑与数据库之间已i ; ; ; 任何外部机构:这些系统的业务逻辑并不需要知道任何其他外部按口 j
I IB
178第22章整洁架构
—
| ■ ■ -------- -------------------------------- f - 了 — ・i
整洁架构
控制器
例
业务实体
展示器
控制流 用例交互层
系统级业务逻辑 
应用级业务逻辑 
接口适配器
框架与驱动程序
用例的输入端
-------------------------------------------- s
用例的输出端
■
*
咎部接口 控制器
图22.1：整洁架构
依赖关系规则
图 22.1中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所
在的软件层次就越高。基本上，外层圆代表的是机制, 内层圆代表的是策略。
当然这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则:
源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向咼层
策略,
换句话说，就是任何属于内层圆中的代码都不应该牵涉外层圆屮的代码，尤其 
是内层圆中的代码不应该引用外层圆屮代码所声明的名字，包括函数、类、变量以 
及一切其他有命名的软件实体。架构整洁之道 _______ ________ _-----------------— —
同样的道理，外层圆中使用的数据格式也不应该被内层圆中的代码所觥 
其是当数据格」弋是由外层圆的框架所生成。尼'之，我们不应该让外层圆中芨 
任何变更影响到内层圆的代码。
业务实体
业务实体这一层中封装的是整个系统的关键业务逻车耳，1 个业务实体既可以訂 
一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它; 
被系统中的其他不同应用复用就可以。 弋
如果我们在写的不是一个大型系统，而是一个单一应用的话，那么我们的业冬 
实体就是该应用的业务对象。这些对象封装了该应用中最通用、最高层的业务逻辑， 
它们应该属于系统中最不容易受外界影响而变动的部分。例如，一个针对页面导前 
方式或者安全问题的修改不应该触及这些对象，一个针对应用在运行时的行为所做 
的变更也不应该影响业务实体。
用例
这里面封装并实现
2a
接口适配器
软件的接口适配器层中通常是一组数据转换器，
务实体而言最方便操作的格式，转化成外部系统（譬 如 ::将数据从对用例和业 
作的格式。例如，这一层中应该包含整个GUI MVC桁如占上：以及"^比）最方便操 
朱。展示器、视图、控制器第 22童整洁架构
都应该属于接口适配器层。而模 
展示器和视图。 再由用例传回
同样的I 这 -层 的代码也会负责将数据从对业务实休钏例,「 
格式，转化为对所米用的持久性框架（譬如数据库）最方便的格式 
层再往内的同心圆中，.... 0
的是SQL数据库，那么所有的SQL语句都应该被限制在这-层的代码中 
是仅限于那些需要操作数据库的代码。
茸最方便操作的
其代码就不应该依赖任何数据库了。譬如说，如果我们采川
.......'—— 而且
当然，这—层的代码也会负责将来自外部服务的数据转换成系统内用例与业务 
实体所需的格式。
框架与驱动程序
图22.1中最外层的模型层一般是由工具、数据库、Web框架等组成的。在这一 层中，我们通常只需要编写一些与内层沟通的黏合性代码。
框架与驱动程序层中包含了所有的实现细节。Web是一个实现细节，数据库也 是一个实现细节。我们将这些细节放在最外层，这样它们就很难影响到其他层了。
只有四层吗
四层。
图22 1中所显示的同心圆只是为了说明架构的结构’真正的架构很可能会超过 
并没有某个规则约定-个系统的架构有且只能有四层。然而’这其中的依顿 
关系原则是不变的。也就是说'源码层面的依赖关匕驚 豐 眇 譽 霧 囂 
次越往内，其抽象和策略的层次越高，同 时 软 件 的 抽 覽 譽 芻 '尸 囂 豐 囂 
策略就越多。最内层的圆中包含的是最通用、最高层的策略’最外层的圆 包 曲 
最具体的实现细节。
跨越边界
181架构整洁之道
这里，我们通常釆用依赖反转原则（DIP）来解决这种相反性。例如，存 
这一类的诰言中，可以通过调整代码中的接口和继承关系，利用源码中的依苗； 
来限制控制流只能在正确的地方跨越架构边界。
假设某些用例代码需要调用展示器，这里一定不能直接调用，因为这样做冬 
反依赖关系原则：内层圆中的代码不能引用其外层的声明。我们需要让业务逻;; 
码调用一个内层接口（图22.1中的“用例输出端”），并让展示器来负责实现龙 
接口。 
「
我们可以采用这种方式跨越系统中所有的架构边界。利用动态多态技术，我- 
将源码中的依赖关系与控制流的方向进行反转。不管控制流原本的方向如何，我『 
都可以让它遵守架构的依赖关系规则。
哪些数据会跨越边界
们 厶 ; 豎 覚 葺 豎界的数据在数据结构上都是很简单的。如果可以的话,我 
点 数 ; 囂 羔 囂 豐 驚简单的可传输数据对象。或者直接通过函数伽 
? 囂 囂 囂 蔦 蠶 ：豐以将数据放入哈希表，或整合成某种对象。这 
要投机取巧宾直接传递业冬 二 :瓷 该 有 f 独立、简单的数据结构。总之,不 譚 驚 囂 需 豔 駕 囂 库 记 录 嗦 同 时 ’这些传递的数据结构中 
体”饗 个 轟 需 蠶 总 厭 结 說 等 我 们 称 之 为 V 
外层代码，违反依赖规则。 °因为这諄于让内层的代码引用
因此，当我们皿行跨也界传输时，-定要采用内层最方便使用的形式第 22章整洁架构
个常见的应用场景
3
接卜来，我们将会在图22.2中看到一个某r v/ k 2 在该系统中，黑 服 务 器 会 从 川 门 那 财 仁 J 豐 豐 ； 蔦 
需 X 爲 越 ; 「 5 「将这」咔息数据包装成.个简 单 二 对 象 , 
彷厶、匚 Y 微传邀到UseCaselnteractoro接下来，我
们z 让 UseCaselnteractor解析数据，并通过它来控制与Entities的交互。 同时，我 们 还 会 用 DataAccessInterface将 Entities需要用 到 的 ，从、 Database加载至I」内存中。随后，UseCaselnteractor会负责从Entities收 集数据，并 将 OutputData组装成另一个简单的Java对象。最后，OutputData 会穿越 Out put Boundary 被传递给 Presenter 0
183架构整洁之道
接 下 来 ，Presenter的 任 务 是 将 O u t Pu t D a t a 重新打包成可腥 
ViewModel,这也是一个简单的咧 对象。ViewModE中 基 本 上 只 包 誥 _ 些 View都会用到的开关数据。同时，OutputDete中可能会包含-些「丁啊 象 占 w 会将其格式化成可对用户展示的字符串’并将其填充到畑;J 中。同理，Currency对象和其他业务相关的数据也会经历类似的操作。如你所「 
Button和 Menuitems的命名定乂位于ViewModel中，并且其中还包括了用于± 知 View层 Button和 Menuitems是否可用的开关数据。
我们可以看出，View除了将ViewModel中的数据转换成HTML格式之外 没有其他功能。
最后，读者必须注意一下这里的依赖关系方向。所有跨边界的依赖线都是指E 
内的，这很好地遵守了架构的依赖关系规则。 ’
本章小结
、 如你所见，遵守上面这些简单的规范并不困难，这样做能在未来避免各种令人 
头疼的问题。通过将系统划分层次，并确保这些层次遵守依赖关系规则，就可以构 
建出 -个 天生可测试的系统，这其中的好处是不言而喻的。而且，当系统外层的这 
些数据库或Web框架过时的时候，我们还可以很轻松地替换它们。
184