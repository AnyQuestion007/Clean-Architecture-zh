61/第 8 章 O C P:开闭原则
开 闭 原 则 （OCP） 是 Bertrand Meyer在 1988年提出】的，该设计原则认为: 设计良好的计算机软件应该易于扩展,
同时抗拒修改。
换句话说，一个设计良好的计算机系统应该在不需要修改的前提卜•就可以轻易 
被扩展。
其实这也是我们研究软件架构的根本目的。如果对原始需求的小小延伸就需要 
对原有的软件系统进行大幅修改，那么这个系统的架构设计显然是失败的。
尽管大部分软件设计师都已经认可了 OCP是设计类与模块时的重要原则，但是 
在软件架构层面’这项原则的意义则更为重大。
下面，让我们用一个思想实验来做一些说明。
思想实验
假设我们现在要设计一个在Web页面上展示财务数据的系统，页面上的数据要 
可以滚动显示，其中负值应显示为红色。
接下来，该系统的所有者又要求同样的数据需要形成一个报表，该报表要能用
□ Q 白打印机打印, 并且其报表格式要得到合理分页，每页都要包含页头、页尾及栏
目名。同时，负值应该以括号表示。
显然，我们需要增加一些代码来完成这个要求。但在这里我们更关注的问题是,
满足新的要求需要更改多少旧代码。
一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为°。
但该如何实现这一点呢？我们可以先将满足不同需求的代码分组（即 SRP）, 
然后再来调整这些分组之间的依赖关系（即DIP） o
］ 请参考 Bertrand Meyer 在 19M 年发表的，由 Prentice Hall 出版的 Object Oriented Software Construction 一书的第23页。
63架构整洁之道
⑴ 理 川 方 式来处理数据流。即先用理 
利用SRP，我们川以按图 勺戈报表的数据结构，最后再用两个不同的报燹
8 1
程序处理原始的财务数据，以"八
图&1： SRP的应用
这里的核心就是将应用生成报表的过程拆成两个不豐操作。即先计算蠅 
数据，再生成具体的展示报表（分别以网页及纸质的形式展示）°
接下来，我们就该修改其源代码之间的依赖关系了。这样做的目的是保证熬 
_ 个操作被修改之后不会影响到另外一个操作。同时，我们所构建的新的组级旋 
应该保证该程序后续在行为上的扩展都无须修改现有代码。
在具体实现上，我们会将整个程序进程划分成一系列的类，然后再将这些务 
割成不同的组件。下面，我们用图8.2中的那些双线框来具体描述一下整个实觅 
在这个图中，左上角的组件是Controller,右 上 角 是 Interactor,右下角是Dat觎 左下角则有四个组件分别用于代表不同的Presenter和 View。 在图&2 中，用＜1＞标记的类代表接口，用＜DS＞标记的则代表数据结构；开族 
头指代的是使用关系，闭合箭头则指代了实现与继承关系。
首先，我们在图8.2中看到的所有依赖关系都是其源代码中存在的依赖遊
这里,从类A 指向类B 的箭头意味着A 的源代码中涉及了 B ,但 是 B的源代蛀 
并不涉及A o因此在图8.2中，F inancialD ataM apper在实现接口时需要恥 FinancialDataGateway 的实现，而 F inancialD ataG atew ay 则完全秒 道 FinancialDataM apper 的实现。第 8 章 O C P:开闭原则
图 &2：先将不同的操作划分为类，再将这些类分割为不同的组件
其次，这里很重要的一点是这些双线框的边界都是单向跨越的。也就是说，上 
图中所有组件之间的关系都是单向依赖的，如图8.3所示，图中的箭头都指向那些 
我们不想经常更改的组件。
让我们再来复述一下这里的设计原则：如果A组件不想被B 组件上发生的修改 
所影响，那么就应该让B 组件依赖于A组件。
所以现在的情况是，我们不想让发生在Pwsen血上的修改影响到Controller,也 不想让发生在View上的修改影响到Presentero而最关键的是，我们不想让任何修改 
影响到 Interactor o 其中,Interactor组件是整个系统中最符合°C P 的。发生在Database.Controller. 
Presenter甚至View上的修改都不会影响到lnteractor°
65架构整洁之道
图 &3：组件之间的关系都是单向的
为什么Interactor会被放在这么重要的位置上呢？因为它是该程序的业务逻辑所 在之处，Interactoi•中包含了其最高层次的应用策略。其他组件都只是负责处理周边 的辅助逻辑，只有Interactor才是核心组件。
虽然Controller组件只是Interactor的附属品，但它却是Presenter和 View所服 
务的核心。同样的，虽然Presenter组件是Controller的附属品，但它却是View所服 
务的核心。
另外需要注意的是，这里利用“层级”这个概念创造了一系列不同的保护层级。 
譬如，Interactor是最高层的抽象，所以它被保护得最严密，而 Presenter比View时 
层级高，但比Controller和 Interactor的层级低。
以上就是我们在软件架构层次上对OCP这一设计原则的应用。软件架构师可以 
根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将 
这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改币 
受到影响。
2
66第 8 章 O C P :开闭原则
依赖方向的控制
如果刚刚的类设计把你吓着了，别害怕！你刚刚在图表中所看到的复杂度是我 
们想要对组件之间的依赖方向进行控制而产生的。
例 如 ,Fi nanci a IReport Generat or 和 Financial Da taMapper 之间的 
Financial Da taGateway 接口 是为了 反转 Interactor 与 Database 之间的依赖关系 
而产生的。同样的，FinancialReportPresenter接口与两个View接口之间也 
类似于这种情况。
信息隐臧
当然，FinancialReportRequester接口的作用则完全不同，它的作用是保 
护 Financial Report Cont roller不过度依赖于Interactor的内部细节。如果没 有这个接口，则 Controller将会传递性地依赖于FinancialEntities □ 这种传递性依赖违反了 “软件系统不应该依赖其不直接使用的组件”这一基本 
原则。之后，我们会在讨论接口隔离原则和共同复用原则的时候再次提到这一点。
所以，虽然我们的首要目的是为了让Interactor屏蔽掉发生在Controller上的修 改，但也需要通过隐藏Interactor内部细节的方法来让其屏蔽掉来自Controller的依
0
本章小结
OCP是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同 
时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件’并 
且将这些组件间的依赖关系按层次结构进行组织’使得高阶组件不会因低阶组件被 
修改而受到影响。Sre 卩  g工 IF二
LSP：里氏替换原则