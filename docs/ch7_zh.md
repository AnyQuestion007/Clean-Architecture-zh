第7 章 S R P :单一职责原则

SRP是 SOLID五大设计原则屮最容易被误解的•个。也许是名字的原因，很多 
程序员根据SRP这个名字想当然地认为这个原则就是指：每个模块都应该只做-件 
事。

没错，后者的确也是•个设订原则，即确保-个函数只完成•个功能。我们在 
将大型函数亜构成小函数时经常会用到这个原则，但这只是•个面向底层实现细W 
的设计原则，并不是SRP的全部。

在历史上，我们曾经这样描述SRP这一设计原则：

任何一个软件模块都应该有且仅有一个被修改的原因o

在现实环境中，软件系统为了满足用户和所有者的要求，必然要经常做出这样 
那样的修改。而该系统的用户或者所有者就是该设计原则中所指的“被修改的原因”。 

所以，我们也可以这样描述SRP：

任何一个软件模块都应该只对一个用户(U ser)或系统利益相关者
( Stakeholder ) 负责。

不过，这里的“用户”和 “系统利益相关者”在用词上也并不完全准确，它们 
很有可能指的是一个或多个用户和利益相关者，只要这些人希望对系统进行的变更 
是相似的，就可以归为一类—— _ 个或多个有共同需求的人。在这里，我们将其称 
为行为者(actor) o

所以，对于SRP的最终描述就变成了：
任何一个软件模块都应该只对某一类行为者负责。
那么，上文中提到的“软件模块”究竟又是在指什么呢？大部分情况下，其最
简单的定义就是指一个源代码文件。然而，有些编程语言和编程环境并不是用源代
码文件来存储程序的。在这些情况下，“软件模块”指的就是一组紧密相关的函数和
数据结构。

在这里，“相关”这个词实际上就隐含了 SRP这-原则。代码与数据就是靠着与 
某一类行为者的相关性被组合在一起的。


或许，理解这个设计原则最好的办法就是计大家来看一些反面案例。反面葡宇
1:重复的假象 ‘
这是我最喜欢举的一个例子：某个工资管理程序屮的Employee类有三个動 
calculatePay () > reportHours () save ()(见图 7」) 。

图 7.1: Employee 类

如你所见，这个类的三个函数分别对应的是三类非常不同的行为者，违反了 SRP 
设计原则。

• calculatePay ()®数是由财务部门制定的，他们负责向CFO汇报。 • reportHours ()函数是由人力资源部门制定并使用的，他们负责向COO 汇报。
• save()函数是由DBA制定的，他们负责向CTO汇报。 这三个函数被放在同一个源代码文件，即同一个Employee类中，程序员这样 做实际上就等于使三类行为者的行为耦合在了一起，这有可能会导致CFO团队的命 
令影响到C 00团队所依赖的功能。
I I I
例如,calculatePay ()函数和reportHours ()函数使用同样的逻辑来计算 
止常工作时数。程序员为了避免重复编码，通常会将该算法单独实现为一个名为
regularHours ()的函数(见图 7 .2 )。第 7 章 SRP:单一职责原则
图 7.2：算法共享
接下来，假设C F O 团队需要修改正常工作时数的计算方法，而C O O 带领的HR
团队不需要这个修改，因为他们对数据的用法是不同的。
这时候，负责这项修改的程序员会注意到calculatePay ()函数调用了 regularHours ()函数，但可能不会注意到该函数会同时被reportHours ()调用。
于是，该程序员就这样按照要求进行了修改，同时CFO团队的成员验证了新算 
法工作正常。这项修改最终被成功部署上线了。
但 是 ，C O O 团队显然完全不知道这些事情的发生，H R 仍然在使用 
reportHours ()产生的报表，随后就会发现他们的数据出错了 ！最终这个问题让 C O O 十分愤怒，因为这些错误的数据给公司造成了几百万美元的损失。
与此类似的事情我们肯定多多少少都经历过。这类问题发生的根源就是因为我们 
将不同行为者所依赖的代码强凑到了一起。对此，SRP强调这类代码一定要被分开。

反面案例2：代码合井

一个拥有很多函数的源代码文件必然会经历很多次代码合并，该文件中的这些 
函数分别服务不同行为者的情况就更常见了。

例如，C T O 团队的D B A 决定要对Employee数据库表结构进行简单修改。与 此同时，C O O 团队的H R 需要修改工作时数报表的格式。
这样一来，就很可能出现两个来自不同团队的程序员分别对Employee类进行 修改的情况。不出意外的话，他们各自的修改一定会互相冲突，这就必须要进行代 
码合并。

在这个例子中，/ 代 辭 杠 仅 机 能 让 C T O 和c o °要求的功能昭 至连CF。原本匸常的功能也可能受册响。
重 宀 卜 、文样的案例还有很多，我们就不一列举了。它们的—个共同蘇 
皐 ：;同 黑 鳥 寫 -份 源 代 码 ,这 很 容 易 造 成 问 题 的 产 生 。
而避免这种问题产生的方法就是将服务不同行为者的代码进行切分。

解决方案

我们有很多不同的方法可以用来解决上面的问题，每一种方法都需要将相利 
函数划分成不同的类。

其中，最简单直接的办法是将数据与函数分离，设计三个类共同使用一个饨 
括函数的、十分简单的EmployeeData类 （见图7.3） ‘ 每个类只包含与之相关的 函数代码，互相不可见，这样就不存在互相依赖的情况了。

Employee Data
EmployeeSaver + saveEmployee
_____ —「
@7.3：三个类互相不可见
PayCalculator + calculatePay HourReporter + reportHours
这种解决方案的坏处在于：程序员现在需要在程序里处理三个类。另一种解涂 
办法是使）1] Facade设计模式（见图7.4） 0
Employee Facade + calculatePay + reportHours + save
_+ calculatePav 
reportHours
Employee Data
图 7.4： Facade 模式
60第7 章 S R P :单一职责原则
这样一来,EmployeeFacade类所需要的代码凰就很少了,它仅仅包含了初始 化和调用三个具体实现类的函数。 r 1 然 ,也有詈程序员更倾向于把最川■要的业务逻辑与数据放在•起，那么我们 
也可以选择将最重要的函数保留在Employee类中，同时用这个类來调用其他没那 么重要的函数（见图7.5）。
Employee ・ employeeData + calculatePay + reportHours + save
> HourReporter + reportHours
EmployeeSaver + saveEmployee
图 7.5 : 将最重要的函数保留在Employee类中, 同时调用其他两个没那么重要的类
个忙
相知

读者也许会反对上面这些解决方案，因为看上去这里的每个类中都只有一个函 
数。事实上并非如此，因为无论是计算工资、生成报表还是保存数据都是一个很复 
杂的过程，每个类都可能包含了许多私有函数。

总而言之，上面的每一个类都分别容纳了一组作用于相同作用域的函数，而在 
该作用域之外，它们各自的私有函数是互相不可见的。

本章小结

单一职责原则主要讨论的是函数和类之间的关系— 但是它在两个讨论层面上
会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则（Common
Closure Principle), 在软件架构层面, 它则是用于奠定架构边界的变更轴心（Axis of
Change）。我们在接下来的章节中会深入学习这些原则。