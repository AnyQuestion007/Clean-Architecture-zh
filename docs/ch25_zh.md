第25章第25章 层次与边界
系统来说，的确可以这样，但稍复杂-些系统侧|.件就远不止三个了。 」
以-个简单的计算机游戏为例。粗略看来，它好像也很符合三个组件的架构设 
定。首先，让UI口负责接收用户输入的数据，并将数据传递给游戏的业务逻辑。然后， 
游戏的业务逻辑会将游戏状态保存在某种持久化数据结构中。但是，仅仅是这样而 
已吗？
基于文本的冒险游戏：Hunt The Wumpus
现在让我们往上面的设想中加入一些细节。假设这个游戏是1972年风靡一时的 
基于文本的冒险游戏：Hunt the Wumpus□这个游戏的操作是通过一些像GO EAST 和 SHOOT WEST这样的简单文字命令来完成的。玩家在输入命令之后，计算机就 
会返回玩家角色所看到的、闻到的、听到的或体会到的事情。在这个游戏中，玩家 
会在一系列洞穴中追捕Wumpus1 o 玩家必须避开陷阱、陷坑以及其他一系列危险。 如果有兴趣，在网上很容易找到该游戏的规则说明。
现在，假设我们决定保留这种基于文本的U I,但是需要将U I与游戏业务逻辑 
之间的耦合解开，以便我们的游戏版本可以在不同地区使用不同的语言。也就是说， 
游戏的业务逻辑与U I之间应该用一种与自然语言无关的API来进行通信，而由UI 
负责将API传递进来的信息转换成合适的自然语言。
如果我们能管理好源码中的依赖关系，就应该像图25.1所展不的那样，多个 
U I组件复用同一套游戏业务逻辑。而游戏的业务逻辑组件不知道，也不必知道U1
正在使用哪一种自然语言。
1 一种虚构的神秘怪兽。 译者注架构整洁之道
图25.1：多个UI
同时，假设玩家在游戏中的状态会被保存在某种持久化存储介质中~~有可链 
闪存，也有可能是某种云端存储，或只是本机内存。无论怎样，我们都并不希 
戏引擎了解这些细节。所以，我们仍然需要创建一个API来负责游戏的业务逻規壬 
件与数据存储组件之间的通信。
由于我们不会希望让游戏的业务逻辑依赖于不同种类的数据存储，所以这里勺 
设计也要合理地遵守依赖关系原则，这样的话，该游戏的结构应如图25.2所示，
图25.2：遵循依赖关系规则的设计
可否采用整洁架构
很显然，这里具备了采用整洁架构方法所需要的—切，包括用例、业务实体以I 
及对应的数据结构都有了】，但我们是否已经找到了所有相应的架构边界呢？ :
例如，语言并不是U I变更的唯-方向。我们可能还会需要变更文字输入/输出 
C 例如鷲的输入/伽可以采用命令行窗口，或者用短信息，或者采用某 
种聊天程丿予。巨里的可能性有很多。
雹 雲 粘 曲 ;爲 鳥 翼 麒 财 防 个 程 序 差 停 艇 .0 行代
196第 25章层次与边界
这就号味着这类变更应该有-个对应的架构边界。也许我们需要构造-个API, 
以便将语吞部分与通信部分隔开，这样一来，该设计的结构应如图25.3所示。
图25.3：修正后的设计图
在图25.3中可以看到，现在系统的结构已经变得有点复杂了。在该图中，虚线 
框代表的是抽象组件，它们所定义的API通常要交由其上下层的组件来实现。例如 
Language部分的API是由English和 Spanish这两个组件来实现的。
我们也可以看到GameRules与Language这两个组件之间的父互是通过—炉 
由GameRules定义，并由Language实现的API来完成的。同样的，Language 
与 TextDelievery之 间 的 交 互 也 是 通 过 由 Language定 义 ， 并由 TextDelievery实现的API来完成。这些API的定义和维护都是由使用方来负责 
的，而非实现方。
如果我们进一步查看GameRules内部，就会发现GameRules组件的代码中 使 用 的 Boundary多态接口是由Language组件来实现的；同时还会发现 
Language组件使用的Boundary多态接口由GameRules代码实现。
如果再探究一下Language组件，我们也会看到类似的情况：它的Bound心 
多态接口是在TextDelievery组件的代码中实现的，而 TextDelievery使用的 Boundary多态接口则由Language来实现°
在所有这些场景中，由Boundary接口所定义的API都是瞅使用者的上一层
组件负责维护的。
不同的具体实现类，例如English、SMS
CloudData都实现f 由抽象的API
197架构整洁之道
组件所定义的多态接口。例如，Language组件中定义的多态接口是由E , 和Spanish这两个组件来定义的。 我们可以去掉所有的具体实现类，只保留API组件来进一步简化上面这张设计 
图，其简化的结果如图25.4所示。
Language ； ! Data Storage ；
Game Rul(es I ‘
1
一 
1 r
I--------------------------------------r I I
j Text Delivery [
图25.4：简化版设计图
请注意图25.4中的朝向设计，所有的箭头都是朝上的。这样©玄昵閃丄es组件 ［警在顶层的位置。这种朝向设计很好地反映了 G a m e R u l e s 作为最高层策略组 
件的事买。
J 面，我们来考虑-驚驚 的 警 首 先 ，所有来自用户的信息都会通过左 
下角的TextDelievery组件传入。当这些宿息被上传到Language组 件 时 就会 转换为具体的命令输入给GameRules组件。然后,GameRules组件:仔青;卜理用 户的输入，并将数据发送给右下角的Datastorage组件。 = 玄丿、贝戈巴 接 F来 ,GameRules会将输出向下传递至U Language组件，将其转咸厶'舌常 
语言并通过 TextDJievery将该语言传递给用户。 ’ 成口匸'
198m
黑鷲需—
交汇数据流
那么，这个例子中是否永远只有这两条数据流呢？当然不是。假设我们现在要 
在网络上与多个其他玩家一起玩这个游戏，就会需要一个网络组件，如图25 5 所示 
这样一来，我们有了三条数据流，它们都由GameRules组件所控制。
Game Rules
| Data Storage ；.
i • i
Language Network
图255增加一个网络组件
BQ
由此可见，随着系统的复杂化，组件在架构中自然会分裂出多条数据流来。
数据流的分割
此时你可能会认为所有的数据流最终都会汇聚到1 个组件匕生活要是果真如 
此简单，那就真是太好了！现实情况往往不如人所愿啊。
这个游戏的GameRules组件。游戏的部 这一部分需要知道游戏中的洞穴如何相
我们可以再来看一下Hunt The Wumpu 分业务逻辑处理的是玩家在地图中的行走
—
赢肃赢乔记住这里箭头的方向代表的是源^的依赖关系’不是数据流的方
2 竄 以 前 ,我 们 曾 称 顶 端 的 组 件 心 :冒 ［J 爲 : 囂 爲 盂 豐 常 心
Practical Guide to Structured Systems Design
199架构整洁之道
连,每个洞穴中有什么物体存在，还要知道如冋竹巩那协1 伸八侈到芳-个航 
以刃如何触发各种需要玩家处理的事件°
但是，汛戏中辻有-组更高层次的策略— 这些策略负责了解玩家的血量，以 
々每个事件的后果和影响。这些策略既可以让玩家逐渐损失血量，也川能由手均 
r物而增加血量。总而言之，游戏的低层策略会负责向高层策略传递事件，例如 FoundFood和FelllnPito而高层组件则要管理玩家状态（如图25.6所示），島 终该策略将会决定玩家在游戏中的输赢。
I-------------------------:
' Player ； I Management '、
Move Management
1 一」_____!____1 --------- 1
1 1
； Language ； $ : 
. 1
; Data Storage :
1 
1
厂 ------ 1 ------ r
1 
1
1 Network ' i ll<________ 1
1
图25.6：管理玩家的高层策略
这些究竟是名、属十架构边界呢？是 否 需 要 设 计 一 个 API来分割 
MoveManagement和 PlayerManagement呢？在回答这些问题之前，让我们把 
问题弄得更有意思~ 点，再往里面加上微服务吧！
宀 倘设我们现在面对的是一个可以面向海量玩家的新版H urit The Wumpus游戏。 亡的 MoveManagmenet组 合 是 由 玩 家 的 本 地 计 算 机 来 处 理 的 。而 PlayerManagement组件则由服务端来处理。但 P l a y e r M a n g a m e n t 组件会为所 
有连接上它的MoveManagement组件提供一个微服务的A P L
在图25.7中,我们为该游戏绘制了-个简化版的设计图。现实中的Network 组件通常会比图中的更复杂…些 但这里的已经足够说明情况了。在图中，可以 
看到MoveMangament PlayerManagment之间存在一个完整的系统架构边界。
200第25章 层次与边界
图25.7：添加一个微服务的API
本章小结
本章究竟想讨论什么呢？为什么要将一个极为简单的、在Komshell中只需200 行代码就能写完的小程序扩展成具有这些系统架构边界的复杂程序？
我们设计这个例子的目的就是为了证明架构边界可以存在于任何地方。作为架 
构师，我们必须要小心审视究竟在什么地方才需要设计架构边界。另外，我们还必 
须弄清楚完全实现这些边界将会带来多大的成本。
同时，我们也必须要了解如果事先忽略了这些边界，后续再添加会有多么困 
难—— 哪怕有覆盖广泛的测试，严加小心的重构也于事无补。
所以作为架构师，我们应该怎么办？这个冋题恐怕没有答案。一方面，就像一 
些很聪明的人多年来一直告诉我们的那样，不应该将未来的需求抽象化。这就是 
YAGNI原则：“You arerft going to need it” ‘ 臆想中的需求事实上住往是不存在的。 
这是一句饱含智慧的建议，因为过度的工程设计往往比工程设计不足还要糟糕。但 
另-方面，如果我们发现自己在某个位置确实需要设置架构边界’却又没有事 
先准备的时候，再添加边界所需要的成本和风险往往是很高的。
现实就是这样。作为软件架构师，我们必须有一点未卜先知的能力。有时候要
略的边界。而且，这不是一次性的决定。我们不能在项目开始时就决定好哪里需要 
界，哪里不需要。相反，架构师必须持续观察系统的演进，时刻注意哪里可 
设计边界，然后仔细观察这些地方会由于不存在边界而出现哪些问题。
当出现问题时，我们还需要权衡一下实现这个边界的成本，并拿它与不实町、 
个边界的成本对比--- 这种对比经常需要反复地进行。我们的目标是找到设置， 
的优势超过其成本的拐点，那就是实现该边界的最佳时机。 3 杲
持之以恒，一刻也不能放松。