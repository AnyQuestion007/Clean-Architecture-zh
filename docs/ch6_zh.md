第 6 章 函数式编程

函数式编程所依赖的原理，在很多方而其实是早尸编程本身出现的。因为函数
式编程这种范式强烈依赖 F Alonzo Church 在 20 壯纪 30 年代发明的 X 演算。

整数平方

我们最好还是用一个例子来解释什么是函数式编程。请看下面的这个例子：坟
段代码想要输出前 25 个整数的平方值。

如果使用 Java 语言，代码如下:

下面我们改用 Clojure 语言来写这个程序，Clojure 是 LISP 语言的一种衍生体,
属于函数式编程语言。其代码如下：

如果读者对 LISP 不熟悉，这段代码可能看起来很奇怪。没关系，让我们换一种
格式，用注释来说明一下吧：

很明显，这里的 println、take、map 和 range 都是函数。在 LISP 中，函数是通过括号来调用的,例如(range)表达式就是在调用 ra n g e 函数。 调用'I 鹽 : : 幻)则是-个匿名函数，该函数用同样的值作为参数
调用「采丛函数。换口 J 话说，该函数计算的是平方值。

现在让我们回过头再看一下这整句代码, 从最内侧的函数调用开始:

- r &nge 函数会返回一个从 0 开始的幣数无穷列表。
- 然后该列表会被传入 map 函数,并针对列表中的每个元素,调用求平方值 的匿名函数，产生了一个无穷多的、包含平方值的列表。
- 接着再将这个列表传入 ta k e 函数，后者会返回-个仅包含前 25 个元素的 新列表。
- p r in tin 函数将它的参数输出，该参数就是上面这个包含了 25 个平方值的 列表。

读者不用担心上面提到的无穷列表。因为这些列表中的元素只有在被访问时才
会被创建，所以实际上只有前 25 个元素是真正被创建了的。

如果上述内容还是让读者觉得云里雾里的话，可以自行学习一下 Clojure 和函数
式编程，本书的目标并不是要教你学会这门语言，因此不再展开。

相反，我们讨论它的主要目标是要突显出 Clojure 和 Java 这两种语言之间的巨 大区别。在 Java 程序中，我们使用的是可变量，即变量 i , 该变量的值会随着程序 执行的过程而改变，故被称为循环控制变量。而 Clojure 程序中是不存在这种变量的, 变量 x —旦被初始化之后，就不会再被更改了。

这句话有点岀人意料: 函数式编程语言中的变量（Variable）是不可变（Vary）
的。

不可变性与软件架构

为什么不可变性是软件架构设计需要考虑的重点呢？为什么软件架构帅要操心
变量的可变性呢？答案显而易见：所有的竞争问题、死锁问题、并发更新问题都是
由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新
问题。如果锁状态是不可变的，那就永远不会产生死锁问题。

换句话说,一切并发应用遇到的问题,一切由于使用多线程、多处理器而引起
的问题，如果没有可变变量的话都不对能发工。

作为一个软件架构师，、"|然应该要对并发问题保持高度关注 ° 我们需要确保自
己设计的系统在多线程、多处理器环境屮能稳定匚作。所以在这里，我们实际应该
要问的问题是：不可变性是否实际可行？

如果我们能忽略存储器打处理器作速度匕的限制 I 那么答案是肯定的。否则的
话，不可变性只有在一定情况下是可行的。

下面让我们来看一下它具体该如何做到可行。

可变性的隔离

一种常见方式是将应用程序，或者是应用程序的内部服务进行切分，划分为可
变的和不可变的两种组件。不可变组件用纯函数的方式来执行任务，期间不更改任
何状态。这些不可变的组件将通过与一个或多个非函数式组件通信的方式来修改变
量状态（参见图 6.1） o

由十状态的修改会导致一系列并发问题的产生，所以我们通常会采用某种事务
型内存来保护可变变量，避免同步更新和竞争状态的发生。

事务型内存基本上与数据库保护磁盘数据的方式 1 类似，通常釆用的是事务或者
重试机制。

卜面我们可以用 Clojure 中的 atom 机制来写一个简单的例子:

在这段代码中，c o u n te r 变量被定义为 atom 类型。在 Clojure 中，atom 是一
类特殊的变量，它被允许在 swap!函数定义的严格条件下进行更改。

至于 swap!函数，如同上面代码所写，它需要两个参数：一个是被用来修改的 atom 类型实例，另一个是用来计算新值的函数。在上面的代码中，in c 函数会将
参数加 1 并存入 c o u n te r 这个 atom 实例。

在这里，swap!所采用的策略是传统的比较+替换算法。即先读取 counter \$ 量的值，再将其传入 in c 函数。然后当 in c 函数返回时，将原先用锁保护起来的 c o u n te r 值与传入 in c 时的值进彳丁比较。如果两边的值一致’则将 in c 函数返回 的值存入 c o u n te r,释放锁。否则，先释放锁，再从头进行重试。 当然，atom 这个机制只适用于上面这种简单的应用程序，它并不适用于解决由 多个相关变量同时需要更改所引发的并发更新问题和死锁问题，要想解决这些问题,
我们就需要用到更复杂的机制。

这里的要点是：―个架构设计良好的应用程序应该将状态修改的部分和不需要
修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。

软件架构师应该着力于将大部分处理逻辑都归于不可变组件中‘可变状态组件
的逻辑应该越少越好。

事件溯源

随着存储和处理能力的大幅进步’现在拥有每秒可以执行数十亿条指令的处理器， 字节内存的计算机已经很常见冲 而 内 存越堰处理速度越快，我
们对可变状态的依赖就会越少。

举个简单的例子,假设某个银行应丿冃程序需要维护客户账户余额信息，当它放
行存取款事务时，就要同时负责修改余额记录 °

如果我们不保存具体账户余额，仅仅保存事务日志’那么当有川查询账户余
额时.我们就将全部交易记录取出，并且每次都得从最开始到当下进行累计。当然，
这样的设计就不需要维护任何可变变量了。

但显而易见，这种实现是有些不合理的。因为随着时间的推移，事务的数目会
无限制增长，每次处理总额所需要的处理能力很快就会变得不能接受。如果想使这
种设计永远可行的话，我们将需要无限容量的存储，以及无限的处理能力。

但是可能我们并不需要这个设计永远可行，而且可能在整个程序的生命周期内,
我们有足够的存储和处理能力来满足它。

这就是事件溯源- 在这种体系下，我们只存储事务记录，不存储具体状态。当
需要具体状态时，我们只要从头开始计算所有的事务即可。

在存储方面，这种架构的确需要很大的存储容量。如今离线数据存储器的增长
是非常快的，现在 1 TB 对我们来说也已经不算什么了。

更重要的是，这种数据存储模式中不存在删除和更新的情况，我们的应用程序
不是 CRUD,而是 CR。因为更新和删除这两种操作都不存在了，自然也就不存在并
发问题。

如果我们有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯
函数式的方式来编程。

如果读者还是觉得这听起来不太靠谱，可以想想我们现在用的源代码管理程序,
它们正是用这种方式工作的！

本章小结

下面我们来总结一下:

- 结构化编程是多对程序控制权的直接转移的限制。
- 面向对象编程是对程序控制权的间接转移的限制。
- 函数式编程是对程序中赋值操作的限制。

这三个编程范式都对程序员提出了新的限制。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。

也就是说，我们过去 50 年学到的东西主要是—— 什么不应该做。

我们必须面对这种不友好的现实：软件构建并不是一个迅速前进的技术。今天
构建软件的规则和 1946 年阿兰•图灵写下电子计算机的第一行代码时是一样的。
尽管工具变化了，硬件变化了，但是软件编程的核心没有变。

总而言之，软件，或者说计算机程序无一例外是由顺序结构、分支结构、循环
结构和间接转移这几种行为组合而成的，无可增加，也缺一不可。
