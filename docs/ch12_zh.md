第12章
组件第 42章 组 件
宀;!件 :丁牛的部暑单元’是整个软件系统在部署过卅中可以独立完成部署的最 
小:体:例如，对于Jaw 来说，它的组件是阿文件。而在Ruby中，它们是 -出 ；|二 丫 中’它们则是DLL文件。总而言之，在编译运行语言中，组件是-组 
二进制:件号集£。而在解释运行语言中，组件则是一组源代码文件的集合。无论 
术用什么编程语言来开发软件，组件都是该软件在部署过程中的最小单元。
、 我们可以将多个组件链接成-个独立可执行文件，也可以将它们汇总成类 
似.W3：文件这样的部署单元，又或者，组件也可以被打包成.ja r 、・d l l 或者・exe 文件’并以可动态加载的插件形式来独立部署。但无论采用哪种部署形式，设计良 
好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以 
被单独开发。
gem
组件发展史
在早期的软件开发中，程序员可以完全掌控自己编写的程序所处的内存地址和 
存放格式。在那时，程序中的第一条语句被称为起源（"②刁）语句，它的作用是声 
明该程序应该被加载到的内存位置。
例如下面这段简单的PDP-8程序。该程序中包含一段名为GETSTR的子程序, 
作用是从键盘上读取一个字符串，并将其存入缓冲区。同时，该程序中还包含一段 
用于测试GETSTR功能的单元测试。
START,
EUFR,
GETSTR,
*200
TLS
CLA
TAD BUFR
JMS GETSTR
CLA
TAD BUFR
JMS PUTSTR
JMP START
3000
0
85架构整洁之道
NXTCH,
dca ptr KSF
JMP -1
KRB
DCA I PTR 
TAD I PTR 
AND K177
ISZ PTR 
tad mcr SZA
JMP NXTCH
K177,
MCR,
177
-15
首先，程序开头的头200命令告诉编译器生成后的代码应该加载到内存地址为 
200 （八进制）的位置。
当然，上面这种编程方式如今应该己经很少见了，因为现在的程序员一般不需 
要考虑程序要加载的内存地址。但这的确是早期程序员们在编程初期就要做的—个 
重要决策，因为当时的程序基本不能被重定位（relocate）。 那么，当时是如何调用库函数呢？上述代码演示了具体调用过程。程序员们需 
要将所有要调用的库函数源代码包含到自己的程序代码中，然后再进行整体编译 
库函数文件都是以源代码而非二进制的形式保存的。
在那个年代，存储设备十分缓慢，而内存则非常昂贵，也非常有限。编译器在 
编译程序的过程中需要数次遍历整个源代码。由于内存非常有限，驻留所有的源代 
码是不现实的，编译器只能多次从缓慢的存储设备中读取源代码。
4(1
这样做是十分耗时的 库函数越多，编译就越慢。大型程序的编译过程经常
需要几个小时。
为了缩短编译时间，程序员们改将库函数的源代码单独编译。而库函数的源K
1 m 年，我就职的第一家公司会将几十盒库函数源代码（打孔纸卡盒）按顺序摆放在一个书架上，肖跚 q豹程序时，只需要将需要用到的库源代码盒取下来，放在新编写代码的最后即可。
in
86第 42章 组 件
码在单独编译后会被加载到-个指定位曽, 比如地Jll: 2000 （八进制）。然后，编译 器会针对该库文件创建•个符号丧（symbol table），并将其和应用程序代码编译在 一起。当程序运行时，它会先加载二进制形式的库文件J 再加载编译过的应用程序,
其内存布局如图12.1所示。
x 0 0 0 -x l7 7 x 2 0 0 -x 3 7 7 x 4 0 0 -x 5 7 7 x 6 0 0 -x 7 7 7
0 0 0 0 -0 7 7 7
1 0 0 0 -1 7 7 7
2 0 0 0 -2 7 7 7
3 0 0 0 -3 7 7 7
4 0 0 0 -4 7 7 7
5 0 0 0 -5 7 7 7
6 0 0 0 -6 7 7 7
7 0 0 0 -7 7 7 7
图 12」：早期程序的内存布局
当然，只要应用程序的代码能够完全存放在地址0000〜1777 （八进制）内，这 
种组织方式就没有任何问题。但是，应用程序代码的大小很快就会超出这个范围。 
为了解决这个问题，程序员们必须将应用程序代码切分成两个不同的地址段，以跳 
过库函数存放的内存范围（具体如图12.2所示）。
X000-X177 x200-x377 x400-x577 X600-X777
0000-0777
1000-1777
2000-2777
3000-3777
4000-4777
5000-5777
6000-6777
7000-7777
________________ 一 -------------------------
_ _______ 一 」 … 一 
-mm---
图 12.2将应用程序内存地址切分成两段
事实上，大部分的古典机型采用的都是CORE内存，后者内存中的内容在关机时不会丢失，库函数经 
常会留在内存中数日之久。
87架构整洁之道
很显然，这种方案也是不对持续的。因为随着函数用小函数的增加，它的兄］ 
也随之增加，我们同样也需要为此划分斯的I乂戚，鹤如作I】述例子中，我们需％ 
7000 (八进制)左右的位置往后追加地址空间。这 样 •來，M 庁和函数库的碎片化 
程度会随着计算机内存的增加而不断增加。
显而易见，这个问题必须要有一个解决方案。
重定位技术
该解决方案就是生成可重定位的二进制文件。其背后的原理非常简单，即程序 
员修改编译器输出文件的二进制格式，使其可以由一个智能加载器加载到任意内存 
位置。当然，这需要我们在加载器启动时为这些文件指定要加载到的内存地址，而 
且可重定位的代码中还包含了一些记号，加载器将其加载到指定位置时会修改这些 
记号对应的地址值。一般来说，这个过程只不过就是将二进制文件中包含的内存地 
址都按照其加载到的内存基础位置进行递增。
这样一来，程序员们就可以用加载器来调整函数库及应用程序的位置了。事实 
上，这种加载器还可以接受多个二进制文件的输入，并按顺序在内存中加载它们， 
再逐个进行重定位。这样，程序员们就可以只加载他们实际会用到的函数了。
除此之外，程序员们还对编m 译器做了另外一个修改，就是在可重定位二进制文 件中将函数名输出为元数据并存储起来。这样一来，如果一段程序调用了某个库函 
数，编译器就会将这个函数的名字输出为外部引用(extemal Feference), 而将库函 
数的定义输出为外部定义^external definition} □加载器在加载完程序后，会将外部 引用和外部定义链接(link)起来。
这就是链接加载器(linking loader)的由来。
链接器
链接加载器让程序员们可以将程序切分成多个可被分别编译、加载的程序段。第42章 组 件
在程序规模较小、外部链接也较少的情况.这个方案■直都很好用。然而在20世 
纪60年代末期到7()年代初期的那段时间里,程序的规模突然有了大幅的增长,情 
况就有所不同了。
显然在这种情况下，链接加载器的处理过程实在是太慢了。 R不说函数库当时 
还存储在磁带卷这样的低速存储设备上，即使是存储在磁盘上，其存取速度也是很 
慢的。毕竟，链接加载器在加载处理过程中必须要读取几十个甚至几百个二进制库 
文件来解析外部引用。因此随着程序规模的扩大，以及函数库中函数的累积，链接 
加载器的加载过程经常会出现需要一个多小时才能完成的情况。
最后，程序员们只能将加载过程和链接过程也进行分离。他们将耗时较长的部 
分—— 链接部分—— 放到了一个单独的程序中去进行，这个程序就是所谓的链接器 
linker} 0 链接器的输岀是一个己经完成了外部链接的、可以重定位的二进制文件， 这种文件可以由一个支持重定位的加载器迅速加载到内存中。这使得程序员可以用 
缓慢的链接器生产出可以很快进行多次加载的可执行文件。
时间继续推移到了 20世纪80年代，程序员们在那时己经用上了 C 这样的高级
编程语言，程序的规模也得到了进一步的扩大，源代码行数超过几十万行在当时己 
经是很普遍的事了。
于是，源代码模块会从・c 文件被编译成・o 文件，然后再由链接器创建出可被 快速加载的可执行文件。那时，虽然编译每个单独模块的速度相对较快，但所有模 
块的累计编译时间较长，链接过程则耗时更久，整个修改编译周期经常会超过数个 
小时。
有时候，程序员们看上去似乎就是一直不停地在原地打转。从 20世纪60年代
一直到80年代，他们所有为提供编译速度所做的努力都被不断增长的程序规模抵消 
了。程序员好像永远也脱离不了长达几个小时的修改编译周期。程序加载的速度一 
直都很快，但是其编译和链接的过程也一直是整个开发过程的瓶颈。
这被我们称为程序规模上的墨菲定律：
程序的规模会一直不断地增长下去，直到将有限的编译和链接时间填 
满为止。
89架构整洁之道
除了墨菲定律，我们还存摩尔迅律J /【：• 2()吐纪 X0年代，两个定律一直在什 
较量，最终以用 律 知 川 •终。I丿、I为倣训的物川尺寸 叩 断 缩 小 ，速度存； 
断提高，同时内存的造价也」直在不断降低，以至丁•人部分〃放在磁盘上的数敝 
可以被缓存在内存中了。而计算机时钟频率则从I MHz上升到了 100MHz。 到了 20世纪90年代中期，链接速度的提升速度已经远远超过了程序规槐?户 
+E速度。在大部分情况下，程序链接的时间已经降低到秒级。这对一些小程序来说. 
即使使用链接加载器也是可以接受的了。
与此同时, 编4 IN 程领域中还诞生了 Active-X、共享库、. j a r 文件等组件形式：-Uj 于计算与存储速度的大幅提高，我们又可以在加载过程中进行实时链接了，链接-■
个.j a r 文件或是共享库文件通常只需要几秒钟时间，由此，插件化架构也就随 生了。
如今，我们用.j 吐 文件、DLL文件和共享库方式来部署应用的插件已经非堂 司空见惯了 c 如果现在我们想要给Minecraft增加一个模块，只需要将.j a r 文件亍 到一个指定的目录中即可。同样的，如果你想给Visual Studio 增 加 Resharper插件,
也只需要安装对应的DLL文件即可。
本章小结
我们常常会在程序运行时插入某些动态链接文件，这些动态链接文件所使用的 
就是软件架构中的组件概念。在经历了 50年的演进之后，组件化的插件式架构己、 
成为我们习以为常的软件构建形式了。
定律.“算机的处理速丿殳、内存、存储密度每］8 个月会增长1倍。这条定律从1950年到20。()" 
一直适用，之后在处理速度方面就停滞不前了。
90
f X — •・・：