第16章架构整洁之道
正如我们Z前所述,
• 系统的用例与正常运行。
• 系统的维护。
• 系统的开发。
• 系统的部署。
用例
I 们先来看第-个支持目标：用 瞅 我 们 认 为 一 鶯 统 釁 驚 :囂 驚 自 
身的设计意图。也就是说，如果某系统是-个购物车应用，那 么 豎 豐 豐 痕 
须非常直观地支持这类应用可能会涉及的所有用例。事实上’运本来就疋架构师们 
首先要关注的问题，也是架构设计过程中的首要工作。软件的架构必须为其用例提
供支持。 ：心 •
然而，正如我们前面所讨论的，一个系统的架构对其行为并没有太大的影响。
虽然架构也可以限制一些行为选项，但这种影响所涉及的范围并不大。—个设计良 
好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为, 
使其在架构层面上可见。
譬如说，一个架构优良的购物车应用看起来就该像是一个购物车应用。该系统 
的主要用例会在其系统结构上明确可见。开发人员将不需要在系统中查找系统所应 
有的行为，因为这些行为在系统顶层作为主要元素已经是明确可见的了，这些元素 
会以类、函数或模块的形式在架构中占据明显位置，它们的名字也能够清晰地描述 
对应的功能。 / i n t R
在第21早 “尖叫的软件架构”中,我们还会更详细地解释这部分内容。
1 用 寫 驚 驚 爲 伫 豐 豐 ± 是 软 件 工 程 或 系 统 工 程 中 对 系 统 如何响应外界请求的描述,是 
•个或多个场景，这些场景说明了系统
-种通过用广的使用场最来获取需求的技札每个用例会提供一个或名个场昌「役 曲 畳 
f 寤 辎 袒 辭第 46章 独 立 性
运行
架构在支持系统运行方面扮演着更实际的角色。如果某个系统每秒要处理
100 0 0 0 个用户，该系统的架构就必须能支持这种级别的吞吐量和响应时间。同样的， 
如果某个系统要在毫秒级的时间内完成对大数据仓库的查询，那么该系统的架构也 
必须能支持这类操作。
对一些系统来说，这意味着它的架构应该支持将其计算部分拆分成一系列小型 
服务，然后让它们并行运行在不同的服务器上。而在另一些系统中，采用一堆轻量 
级线程，然后让这些线程共享一个运行在单处理器上的进程的地址空间。还有一些 
系统，它们可能只是一组运行在独立地址空间内的进程。甚至有些系统设计为一个 
单进程的单体程序就够了。
虽然看起来有点奇怪，但上述问题的决策的确也应该属于一个优秀的架构师为 
我们保留的可选项之一。毕竟一个按照单体模式编写的系统，它依赖的必然是单体 
结构，之后再想把它改造成多进程、多线程或微服务模式可就没有那么容易了。相 
比之下，如果该系统的架构能够在其组件之间做一些适当的隔离，同时不强制规定 
组件之间的交互方式，该系统就可以随时根据不断变化的运行需求来转换成各种运 
行时的线程、进程或服务模型。
开发
系统的架构在支持开发环境方面当然扮演着重要的角色，我们在这里可以引述 
一下康威定律：
任何_ 个组织在设计系统时，往往都会复制出一个与该组织内沟通结
构相同的系统。
一个由多个不同目标的团队协作开发的系统必须认有MI丿、'/〕的软件架构。这样， 
这些团队才可以各自独立地完成工作'不会彼此干扰。这就需要恰当地将系统切分架构整洁之道
汕 .后 才 能 将 这 些 组 件 分 配 给 不 同 恤 , 
为-系列隔离艮好、 川
各自独立开发。
咅0署
. 个 系 统 的 架 构 在 其 部 營 囂 需 需 需 常 爲 脚 ; : ; ； 
定是实现“、刻 汛 署 _ . 1: : 严 格 要求”的目录与文件。总而言乙」
寫 解 爲 蔦 爲 需 之 …
冃样的这凹也需要通过正确地划分、隔离系统组件来决现’运其中包括” 
一 些 霊 盘 席 系统黏合在-起，正确地启动、连接并监控每个軒
保留可选项
一个设计良好的架构应该充分地权衡以上所述的所有关注点，然后尽可能塔 
成一个可以同时满足所有需求的组件结构。这说起来还挺容易的，不是吗？
事实上，要实现这种平衡是很困难的。主要问题是，我们在大部分时间里赶 
法预知系统的所有用例的，而且我们也无法提前预知系统的运行条件、开发团恥
结构，或者系统的部署需求。更糟糕的是，就算我们能提前了解这些需求，随着艮
统生命周期的演进，这些需求也会不可避免地发生变化。总而言之，事实上我厲 
要达到的目标本身就是模糊多变的。真实的世界就这样。
0
134
第46章独立性
按层解耦
、从用例的角度来看，架构师的目标是让系统结构支持其所需要的所有用例。但 
是问题恰恰是我们无法预知全部的用例。好在架构师应该还是知道整个系统的基本 
i殳计意图的。也就是说，架构师应该知道自己要设计的是一个购物车系统，或是运 输清单系统，还是订单处理系统。所以架构师可以通过采用单一职责原则（SRP） 
和共同闭包原则（CCP）, 以及既定的系统设计意图来隔离那些变更原因不同的部 
分，集成变更原因相同的部分。
哪些部分的变更原因是不同的呢？这在有些情况下是很显而易见的。譬如，用 
户界面的变更原因肯定和业务逻辑是不相关的，而业务用例则通常在两边都存在着 
相关的元素。所以很显然，优秀的架构师应该会将用例的UI部分与其业务逻辑部分 
隔离，这样这两部分就既可以各自进行变更，也能保证用例的完整清晰。
而业务逻辑则既可以是与应用程序紧密相关的，也可以是更具有普适性的。例 
如，对输入字段的校验是一个与应用程序本身紧密相关的业务逻辑。相反，计算账 
户利息以及清点库存则是一个与具体领域更为相关的业务逻辑。这两种不同的业务 
逻辑通常有着不同的变更速率和变更原因—— 它们应该被相互隔离，以方便各自的 
变更。
至于数据库，以及其所采用的查询语言，甚至表结构，这些都是系统的技术细 
节信息，它们与业务规则或UI毫无关系。这就意味着它们的变更原因、变更速率必 
然与系统的其他方面各不相同。因此，架构师也应该将它们与系统其他部分隔离， 
以方便各自的变更。
这样一来，我们就发现了一个系统可以被解耦成若干个水平分层 
应用独有的业务逻辑、领域普适的业务逻辑、数据库等。
U 1界面、
I I I架构整洁之道
用例的解耦
「么不同原因的变更呢?答案正是这豐警豊譬如说,赴
龙川例也是上述系统水平分层的—个个垂直切片。每个用例程
接卜•来,还有什
新订单的用例与
变更的速率也不同。因此,J
与此同时，这些... .. 丙“ 「"叫 8 亠 「
用 牡 些 5 、皿应用的业务逻供、应用无关的业务逻辑以I据库功飽因此 
我们时系统水平切分成多个分层的同时，也在按用例将其切分成多个垂直切片，
为广史现这样的解耦，我们应该将增加订单这个用例的U I与删除订单用£ 
UI分卄。而且，对业务逻辑的部分、数据库的部分，也要做同样的事情，将其按军 
用例进行垂直切分。
由此，我们可以总结出一个模式：如果我们按照变更原因的不同对系统进谟 
耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例。如果我们匪 
对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是不同面三
UI与数据库，因此增加新用例就更不太可能会影响旧有的用例了。
解耦的模式
•・・
现在我们来想想所有的这些解耦动作对架构设计的第二个目标— 系统运彳亍一 
尤竟有什么意义。如果不同面向之间的用例得到了良好的隔离，那么需要高吞隨 
的川例就和需要低吞吐量的用例互相自然分开了。如果U［和数据库的部分能从业、 
逻辑分离出来，那么它们就可以运行在不同的服务器上。而且需要较大带宽测 
也可以在多个服务器上运行多个实例。
“ 覚 c 种按用例解耦的动作是有利于系统运行的。然而出于系统运能 黑 H 我们旳解耦动作还应该注意选择恰当的模式。譬如，为了在不同的弓 
1 坯仃'被隔禺的组件不能依赖于某个处理器上的同-个地址空间，它们拠
136第46章独立性
独立的服务，然后通过某种网络来进行通伫o 许多架构帅将匕而这种纠件称为“服务,，或“微皿存”，至「畀前者胚是后者， 
往往取决于某些非常模糊的代码行数阈值。对于这种慕尸服务来构建的架构,架构 
师们通常称之为面向服务的架构(serviccoriented architecture)。
如果因为这里提到了 SOA这个概念而引起了某些读者的警觉，请不用担心,
在这里并没有鼓吹SOA是一种最佳的软件架构，或者微服务就是未来的潮流。我只 
是认为有时候我们必须把组件切割到服务这个应用层次。
请记住，一个设计良好的架构总是要为将来多留一些可选项，这里所讨论的解 
耦模式也是这样的可选项之一。
接下来，在我们继续深入探讨这个话题之前，先回过头来看看其他两个设计目 
标。
开发的独立性
我们进行架构设计的第三个目标是支持系统的开发。很显然，当系统组件之间 
被高度解耦之后，开发团队之间的干扰就大大减少了。譬如说’如果系统的业务逻 
辑与其UI无关，那么专注于UI开发的团队就不会对专注于业务逻辑开发的团队造 
成多大的影响。同样的，如果系统的各个用例之间相互隔离’那么专注于add。应 r 用例的团队就不太可能干扰到负责d e l e t e °r d e r 用例的团队。 口要军统按昭其水平分层和用例进行了恰当的解耦’整个系统的架构就可以支 
持多团:鶯亲管团队组织形式是分功能开发、分组件开发、分层开发’还是按 
照别的什么变量分工都可以。
部署的独立性
实际上,架构整洁之道
如果解耦匸作做得好, 
分层实现和具体用例。 
新的ja r文件‘或川动
蔦 醫 囂 其 他 部 分 将 完 全 不 受 岬 I
重复
架构师们纟常会钻进—个牛角尖— 害怕重复。
、”犬，重复在软件行业里一般来说都是坏事。我们不喜欢重复的代码，与 
真的出现重复时，我们经常会感到作为一个专业人士’自己是有责任减少或険 
种重复的。
但是重复也存在着很多种情况。其中有些是真正的重复，在这种情况下，割、 
实例上发生的每项变更都必须同时应用到其所有的副本上。重复的情况中也有飞 
是假的，或者说这种重复只是表面性的。如果有两段看起来重复的代码，它们走弓 
是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两計 
码就不是真正的重复。等我们几年后再回过头来看，可能就会发现这两段代码是壬
常不一样的了。
现在，我们假设某系统中有两个用例在屏幕展现形式上非常类似。每当这稠 
候，架构师们就很可能非常想复用同一段代码来处理它们的屏幕展示。那么阳 
到底是占应该这样做呢？这里是真正的重复，还只是一种表面性的重复？
恐怕这里很可能只是表面性的重复。随着时间推移，这两个用例的屏幕补 
能可能会各自演变，最终很可能完全不同。正是由于这样的原因，我们必须加触 
心地避免让这两个用例复用同一段代码，否则，未来再想将它们分开会面临肿 
挑战。 站 I?耦匚
当我们按用例垂直切分系统时,
円M田初冷T 「，门 「 这样的问题会经常出现。我们经常遇到丿；
E j H 爲 : 豐 驚 了 -起 。不管是因为心们展现形式类似,I I 隸 腐 即 邹 豊 表 结 构 等 , 总 之 ,我 们 -定 要 小 心避免陷入
「 润 水的应徼丿又脸模式中。一用亜粘加2+八— ¥ 址口甘财那觀鄭
■ ■■
138第4 6 章独立性
意义上的重复 o
1'可样I打道理，号我们对系统进行水平分层时，也可能会发现某个数据库记录的 
箱构和某个屏幕展示的数据接口非常和似。我们可能也会为了避免仰仙建一个看起 
来相同的视图模黑并在两者之间复制元素，而选择直接将数据库记录传j弟给U I层。 我们也一定要小心，这里几乎肯定只是—种表面性的重 而冃 另外创建一个视
医模型并不会花费太多力气，这可以帮助我们保持系统水平分层z 间的隔离。
再谈解耦模式
让我们再回到解耦模式的问题上来。按水平分层和用例解耦一个系统有很多种 
方式。例如，我们可以在源码层次上解耦、二进制层次上解耦（部署），也可以在 
执行单元层次上解耦（服务）。
• 源码层次：我们可以控制源代码模块之间的依赖关系，以此来实现一个模块 
的变更不会导致其他模块也需要变更或重新编译（例如Ruby Gem） ° 在这种解耦模式下，系统所有的组件都会在同一个地址空间内执行，它们会 
通过简单的函数调用来进行彼此的交互。这类系统在运行时是作为一个执行 
文件被统一加载到计算机内存中的。人们经常把这种模式叫作单体结构。
• 部署层次：我们可以控制部署单元（譬如jar文件、DLL、共享库等）之间 的依赖关系，以此来实现一个模块的变更不会导致其他模块的重新构建和部
在这种模式下，大部分组件可能还是依然运行在同一个地址空间内，通过彼 
此的函数调用通信。但有一些别的组件可能会运行在同一个处理器卜的其他 
进柑内，使用跨进程通信，或者通过socket或共享内存进行迪信。这电最 重要的是，这些组件的解耦产生出许多可独立部署的单兀，例如问乂件、
— 彳牛禾廿DLL o ・ 戶'欠• 我们可以将组件间的依赖关系降低到数据结构级别’然后仅通 
翥 : 寫 囂 ; 体 ，它们的变更不会影响其他地方（例如常见的服架构整洁之道
厶匕J姿 「71
例如，我们不难想象，-
可創就会需要将其某些组件j 行在一台服务器上时，我们） 、
可能需要进行部署单元层次的解耦，甚至服务层次的解耦。
A
另.个解决方案（似乎也是目前最流行的方案）是，默认就米用服务层次的緊 
耦。这种做法的问题主要在于它的成本很高，并且是在鼓励粗粒度的解耦。毕竟, 
无论微服务有多么“微”，其解耦的精细度都可能是不够的。
服务层次解耦的另一个问题是不仅系统资源成本高昂，而且研发成本更高。E 
理服务边界不仅非常耗费内存、处理器资源，而且更耗费人力。虽然内存和处理器 
越来越便宜，但是人力成本可一直都很高。
通常，我会倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务 
的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。
在这种方式下，系统最初的组件隔离措施都是做在源码层次上的，这样的解裁 
可能在整个项目的生命周期里已经足够了。然而， 
求出现，那么将某些组件解耦到部署单元层次就可能够了
当然，随着系统在开发、部署、i 挑选一下可以将哪些可部署单元转化为服务，
而随着时间的流逝，
白匕
WWW
部署,
如果部署和开发方面有更高的需 
一，起码能撑上一阵。
运行各方面所面临的问题持续增加，我们甌 
-并且逐渐将系统向这个方向转变。
盘 囂 囂 蠶 第 逬 从 单 体结构开始，以 单 -文 件 胪 
独的可部署单元，甚至是独立的服务或者微服务。第 16章独立 性
最后还能随着情况的变化，允许系统逐渐回退到单体结构o 并且，一个设汁良好的架构在上述过程中述应该能保护I系统的大部分卜马不受 
变更影响。对整个系统来说，解耦模式也应该兄 '个可选项。我们在进行大型部署 
时可以采用一种模式，而在进行小型部署时则可以釆用另一种模式。
本章小结
是的，要达到上述要求难度不小。我并没有说系统的部署模式就一定要是某种 
简单的配置项（虽然在某些情况下的确应该这样做）。这里的主要观点认为，一个
系统所适用的解耦模式可能会随着时间而变化，优秀的架构师应该能预见这一点, 
并且做岀相应的对策。