第 19章策略与层次
本［上’"用的软件系统都是一组策略语句的集合。是的，可以说计算机程序 
不心就是一组仔细描述如何将输入转化为输出的策略语句的集合。
、乂在 人 务 小 型 系 统 (nontrivial system) 中，翳体业务策略通常都可以被拆解 为多［更小的策略语句。-部分策略语句专门用于描述计算部分的业务逻辑，另一 
部分策略语句则负责描述计算报告的格式。除此之外，可能还会有一些用于描述如
何校验输入数据的策田
软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变 
更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个 
组件中。反之，变更原因、时间和层次不同的策略则应该分属于不同的组件。
II
II
架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个
节点代表的是一个拥有相同层次策略的组件 , 每一条单向链接都代表了一种组件之
间的依赖关系，它们将不同级别的组件链接起来。
这里提到的依赖关系是源码层次上的、编译期的依赖关系。这在Java语言中就 
是指im p o rt语句，在 C#语言中就是指u sin g 语句，在Ruby语言中就是指re q u ire 
语句。这里的依赖关系都是在编译过程中所必需的。
在一个设计良好的架构中，依赖关系的方向通常取决于它们所关联的组件层次。 
一般来说，低层组件被设计为依赖于高层组件。
层 次 (Level)
我们对“层次”是严格按照“输入与输出之间的距离”来定义的。也就是说， 
一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的 
策略在系统中的层次是最低的。
在 图 19 1 中，我们看到的是一个简单加密程序的数据流向图，该程序从输入设 
备读取字符，然后用查表法转换这些字符'并将转换后的字符输出到输出设备。我 
们将图中数据的流向用弯曲实心箭头标识了出来，而对于经精妙设计过的源码中的
163架构整洁之道
依赖关系则使用直虚线来标识。
图 19」：简单加密程序
在 图 19.1中，丁工ads丄Ate组件是这个系统中层次最高的组件，因为该组件距 离系统输入/输岀距离最远J
另外需要注意的是，图 19.1中的数据流向和源码中的依赖关系并不总处于同一 
方向上。这也是软件架构设计工作的一部分。我们希望源码中的依赖关系与其数据 
流向脫钩，而与组件所在的层次挂钩。
但我们很容易将这个加密程序写成下面这样，这就构成了一个不正确的架构: 
function encrypt() { while (true) writeChar (translate(readChar()))；
}
L面 这 I和序架构设计的错误在于，它让高层组件中的函数ericrypt ()依赖于 
低层组件中的函数readChar ()与 writeChar ()。
更好的系统架构设计应 如 图 19.2所示。请 注 意 图 19.2中被虚线框起来的 
总 囂 T 薦 蟲 霜 囂 蔦 爲 ： — —
IS1
Meilir Page-Jones A 他的 The Practical Guide to Struct^ 1 o 1H 版社，1988年 出 版 )_书 中将这个组件称为“中 央 转 换 器 如 2加 购 ◎ (Y ourdonP""第 19章策略与层次
Encrypt
Char Reader Char Writer
Console Reader
Console Writer
E 19.2：更好的系统架构设计图
在 图 19.2中，ConsoleReader和 Consolewriter都属于具体类。由于它们 
与输入/输岀最近’因此属于低层组件。
另外应该注意的是，这个架构将高层的加密策略与低层的输入/输出策略解耦了° 
也就是说，当输入/输岀部分的策略发生变更时，它们不太可能会影响加密部分的策
II 
II
正如之前提到的，我们应该根据策略发生变更的方式来将它们分成不同的组件。
变更原因和变更时间相同的策略应在SRP和 ccp这两个原则的指导下合并为同一 组件。离输入/输出最远的策略一一高层策略一 
变更，其原因也比低层策略所在的组件更重大。
一般变更没有那么频繁。即使发生 
反之，低层策略则很有可能会频繁
地进行一些小变更。
例如，即使在这个简单的加密程序中，加密算法发生变更的可能性也要远小于 
10设备发生变更的可能性。如果加密算法真的要变更，也很有可能比I/O设备的变 
更更重大。
通过将策略隔离，并让源码中的依赖方向都统一调整为指向高层策略，我们可 
以大幅度降低系统变更所带来的影响。因为一些针对系统低层组件的紧急小修改几 
乎不会影响系统中更高级、更重要的组件。
165架构整洁之道
从 另 一 个 伯 度 畑 低 层 组 时 册 高 层 组 吶 杯 
示了这种关系,我们可以看到E n cry p t" 
知，而 W Devices组件则依赖于閃门丫卩丄 o n 组件。 所
匸 Encryption 10 Devices
图 19.3： 低层组件应该成为高层组件的插件
本章小结
综上所述，本章针对策略的讨论涉及单一职责原则（SRP）、开闭原则（OCP）、 
共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽 
象原则（SAP） o 读者可以自行结合之前的内容来匹配每个原则所适用的场景以及 背后的原因。第20章
业务逻辑架构整洁之道
如 果 我 们 要 将 自 訓 酗 冋 分 常 时 插 件 两部分’就必须 更 倾 
了解业务逻辑究竟是什么它到底有几 和 …
严格I ; ，业务逻辑就是程序中那些真正用于赚钱或警豐 务 讐 ■ 
刎 格 爲 • 泌 这 昨 沁 眦 心 曲 机 上 实 现 的 '丿 "人 工 执 它 们 齢 
f l 赚代匕的柞用都是一样的I
例如张行要对借贷收取碾利息这个逻辑就是银行获取收入方面的一条业务 
逻辑, 它來说，我们通过计算机来计算利息，还是让一个银行职员用计算器来计 
算利息并不重要。
我们通常称这些逻辑为“关键业务逻辑”，因为它们是一项业务的关键部分， 
不管有没有自动化系统来执行这项业务，这—点是不会改变的。
“关键业务逻辑”通常会需要处理一些数据，例如，在借贷的业务逻辑中，我们 
需要知道借贷的数量、利率以及还款日程。
我们将这些数据称为“关键业务数据”，这是因为这些数据无论自动化程序存 
在与否，都必须要存在。
m
关键业务逻辑和关键业务数据是紧密相关的，所以它们很适合被放在同一个对 
象中处理。我们将这种对象称为“业务实体(Entity) ” 1 o
1 窗这个沁概念- 书的名,字人是I曲var 山Jaco川bson版起 的；(,诸寫参爲in T ：. ；圖. 等AA 人. 合A 著的。回 。皿 畅/ " f阿 e
业务实体
业务实体实际上就是计算机系统中的一种对象，这种对象中包含了一系列用于 
操作关键数据的业务逻辑。这些实体对象要么直接包含关键业务数据，要么可以很 
容易地访问这些数据。业务实体的接口层则是由那些实现关键业务逻辑、操作关键 
业务数据的函数组成的。 - •
例如，/土图20」中,我们看到的是一个对应于借贷业务的实体类Loan的UML