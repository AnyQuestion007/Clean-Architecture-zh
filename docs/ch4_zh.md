第 4 章 结构化编程

架构整洁之道

Edsger Wybc Dijkstra 于 1930 年出生在荷兰鹿特丹。生于乱世，他亲身经历了第二次世界大战中的鹿特丹大轰炸、德国占领荷兰等事件。1948 年,他以数学、物理、化学以及生物全满分的成绩高中毕 4ko 1952 年 3 ）\，年仅 21 岁的 Dijkstra （此时距 离我出生还有 9 个月时间）入职荷兰阿姆斯特丹数学中心，成为了荷兰的第一个程序员。

1955 年，在从事编程工作 3 年之后，当时还是一个学生的 Dijkstra 就认为编程相比理论物理更有挑战性，因此他选择将编程作为终身职业。

1957 年，Dijkstra 与 Maria Debcts 结婚了。在当时的荷兰，新郎新娘必须在结婚 仪式上公布自己的职业。而当时的荷兰官方政府拒绝承认“程序员”这一职业，因为他们从来没有听说过。最 终 Dijkstra 不得不继续使用"理论物理子豕这一职位名称。

Dijkstra 和他的老板 Adriaan van Wijingaarden 曾经讨论过将“程序贝 当作终身职业这件事，Dijkstra 最担心的是由于没有人认真地对待过编程这件事或者将它当作 是一门学术学科对待，他的科研成果可能将不会得到认真对待。而 Adriaan 则建议 Dijkstra：为什么不亲自去开创这门学科呢?

当时还是真空管阶段。计算机体积巨大，运行缓慢，还非常容易出故障，功能（与今天对比）十分有限。人们还是直接使用二进制数，或者使用非常原始的汇编语言编程。计算机的输入方式则还是用纸卷带或者是打孔卡片 ° 要想执行完整的编辑、编译、测试流程是非常耗时的，通常需要数小时或者数天才能完成。

Dijkstra 就是在这样原始的条件下做出其非凡的成就的。

可推导性

Dijkstra 很早就得出的结论是：编程是一项难度很大的活动。一段程序无论复杂 与否，都包含了很多的细节信息。如果没有工具的帮助，这些细节的信息是远远超过一个程序员的认知能力范围的。而在一段程序中, 哪怕仅仅是一个小细节的错误， 也会造成整个程序出错。

Dijkstm 提出的解决方案是采用数学推导方法。他的想法是借鉴数学中的公理(Postulate). 定 理 (Theorem) 、推 论 (Corollary) 和 引 理 (Lemma), 形成一种欧几里得结构。Dijkstra 认为程序员可以像数学家一样对自己的程序进行推理证明。 换句话说，程序员可以用代码将一些已证明可用的结构串联起来，只要自行证明这些额外代码是正确的, 就可以推导出整个程序的正确性。

当然，在这之前，必须先展示如何推导证明简单算法的正确性，这本身就是一件极具挑战性的工作。

Dijkstra 在研究过程中发现了一个问题：goto 语句的某些用法会导致某个模块 无法被递归拆分成更小的、可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。

goto 语句的其他用法虽然不会导致这种问题，但是 Dijkstra 意识到它们的实际效果其实和更简单的分支结构 if-then -else 以及循环结构 do-while 是一致的。如果代码中只采用了这两类控制结构，则一定可以将程序分解成更小的、可证明的单元。

事实上，Dijkstra 很早就知道将这些控制结构与顺序结构的程序组合起来很有用。 因为在两年前，Bohm 和 Jocopini 刚刚证明了人们可以用顺序结构、分支结构、循环 结构这三种结构构造岀任何程序。

这个发现非常重要：因为它证明了我们构建可推导模块所需要的控制结构集与构建所有程序所需的控制结构集的最小集是等同的。这样—来，结构化编程就诞生了。

Dijkstra 展示了顺序结构的正确性可以通过枚举法证明，其过程与其他一般的数 学推导过程是一样的：针对序列中的每个输入，跟踪其对应的输出值的变化就可以了。

同样的，Dijkstra 利用枚举法又证明了分支结构的可推导性。因为我们只要能用 枚举法证明分支结构中每条路径的正确性，自然就可以推导出分支结构本身的正确性。

循环结构的证明过程则有所不同，为了证明一段循环程序的正确性，Dijkstm 需 要采用数学归纳法。具体来说就是，杵先要用枚举法证明循环 1 次的正确性。接下来再证明如果循环 N 次是正确的，那么循环 N+1 次也同样也是正确的。最后还要用枚举法证明循环结构的起始与结束条件的正确性。

尽管这些证明过程本身非常复杂和烦琐，但确实是完备的。有了这样的证明过程，用欧几里得层级构造定理的方式来验证程序正确性的目标，貌似近在咫尺了。

goto 是有害的

1968 年，Dijkstra 曾经给 CACM 的编辑写过一圭寸信。这圭寸信后来发表于 CACM 3 月刊，标题是 Go To Statement Considered Harmful', Dijkstra 在信中具体描绘了他对三种控制结构的看法。

这可捅了个大篓子。由于当时还没有互联网，大家还不能直接上网发帖来对 Dijkstra 进行冷嘲热讽，他们唯一能做的，也是大部分人的选择，就是不停地给各种公开发表的报刊的编辑们写信。

可想而知，有的信件的措辞并不那么友善，甚至是非常负面的。但是，也不乏强烈支持者。总之，这场火热的争论持续了超过 10 年。

当然，这场辩论最终还是逐渐停止了。原因很简单：Dijkstra 是对的。随着编程 饴言的演进，got。语句的重要性越来越小，最终甚至消失了。如今大部分的现代编 程饴言中都已经没有了 g o to 语句。哦，对了，LISP 里从来就没有过！

现如今，无论是否自愿，我们都是结构化编程范式的践行者了，因为我们用的编程语言基本上都已经禁止了不受限制的直接控制转移语句。

或许佝些人会指出，Java 中的带命名的 break 语 句 或 者 Exception 都 和 goto 很类似。事 弘 I 卜些语法结构与老的编程语言（类 似 FORTRAN 和 COBOL）中的完全无限制的 g o to 语句根本不…样。就算那些还支持 goto 关键词的编程语言也通常限制了 goto。的目标不能超岀当前函数范围。

功能性降解拆分

既然结构化编程范式可将模块递归降解拆分为可推导的单元，这就意味着模块了可以按功能进行降解拆分。这样一来，我们就可以将一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此无限递归。更重要的是，每个被拆分出来的函数也都可以用结构化编程范式来书写。

以此为理论基础，在 20 世纪 70 年代晚期到 10 年代中期出现的结构化分析与结构化设计工作才能广为人知。Ed Yourdon> Larry Constantinex Tom DeM arco 以及 Meilir Page Jones 在这期间为此做了很多推广工作。通过采用这些技巧，程序员可以 将大型系统设计拆分成模块和组件，而这些模块和组件最终可以拆分为更小的、可证明的函数。

形式化证明没有发生

但是，人人都用完整的形式化证明的一天没有到来。大部分人不会真的按照欧几里得结构为每个小函数书写冗长复杂的正确性证明过程。。Dijkstra 的梦想最终并 没有实现。没有几个程序员会认为形式化验证是产出高质量软件的必备条件。

当然，形式化的、欧几里得式的数学推导证明并不是证明结构化编程正确性的唯一手段。下面我们来看另外一个十分成功的策略：科学证明法。

科学来救场

科学和数学在证明方法上有着根本性的不同，科学理论和科学定律通常是无法被证明的，譬如我们并没有办法证明牛顿第二运动定律 F = m a 或者万有引力定律 F^Gmxm^r'是正确的, 但我们可以用实际案例来演示这些定律的正确性，并通过高精度测量来证明当相关精度达到小数点丿 I「筈少位时，被测量对象仍然…直满足坟？
定律。但我们始终洱仃办法像用数学方法一样推导出这个定律。而且，不管我们戏
行多少次山确的实齡，也无法排阶今后会行什策 1 次/验可以推翻牛顿第二运动臬
律与万有引力定律的可能性。

这就是科学理论和科学定律的特点：它们可以被证伪，但是没有办法被证明。

但是我们仍然每天都在依赖这些定律生活。开车的时候，我们就等于是在用性命担保 F=ma 是对世界运转方式的一个可靠的描述。每当我们迈岀一步的时候，和 等于在亲身证明 F=G 加］力 2 , 是正确的。

科学方法论不需要证明某条结论是正确的，只需要想办法证明它是错误的。赁果某个结论经过一定的努力无法证伪, 我们则认为它在当下是足够正确的。

当然，不是所有的结论都可以被证明或者证伪的。举一个最简单的不可证明的例子: “这句话是假的”，非真也非伪。

最终，我们可以说数学是要将可证明的结论证明，而与之相反，科学研究则是要将可证明的结论证伪。

测试

Dijkstra 曾经说过“测试只能展示 Bug 的存在，并不能证明不存在 Bug” ，换句 话说，一段程序可以由一个测试来证明其错误性，但是却不能被证明是正确的。濒试的作用是让我们得出某段程序已经足够实现当前目标这一结论。

这一事实加带来的影响是惊人的。软件开发虽然看起来是在操作很多数学结构,其实不是一个数学研究过程。恰恰相反，软件开发更像是一门科学研究学科，我们通过无法证伪来证明软件的正确性。

注意，这种 i 止伪过程只能应用于可证明的程序上。某段程序如果是不可证明的, 例如，其屮采用了不加限制的 goto 语句，那么无论我们为它写多少测试，也不能够证明其正确性。

结构化编程范式促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。

本章小结

结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。这就是为什么现代编程语言一般不支持无限制的 goto 语句。更重要的是, 这也是为什么在架构设计领域，功能性降解拆分仍然是最佳实践之一。

无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务。为了达到这个目的，他们需要将类似结构化编程的限制方法应用在更高的层面上。

我们在接下来的章节中将会深入研究这些限制性的方法。
