
第15章 什么是软件架构

的J怏刀与种秘感，因此谈论架构总让人有 
技术分析的感觉。毕竟,进阶到软件架构这 
示「 愀件架构师总魁紅人一种权力非凡、
程师没有梦朋丿1成为•个软件架构师呢?

那么，究竟什么才是“软件架构”呢?软件架构师的工作内容究竟是什么?这 
项丁作又是什么时候进行的呢？

首先，软件架构师自身需要是程序员，并且必须一直坚持做「线程序员，绝对 
愛听从那些说应该让软件架构师从代码中解放出来以专心解决高阶问题的伪建议: 
不是这样的！软件架构师其实应该是能力最强的一群程序员，他们通常会在自身承 
接编程任务的冋时» 逐渐引导整个团队向一个能够最大化生产力的系统设计方向前 
・・・
如果不亲身承受因系统设计而带来的麻烦，就体会不到设计不佳所带来的痛苦，接 
着就会逐渐迷失正确的设计方向。
软件系统的架构质量是由它的构建者所决定的，软件架构这项工作的实质就是 
规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通 
信的方式。
而设计软件架构的目的，就是为了在工作中更好地对这些组件进行研发、部署、 
运行以及维护。
可能长时间地保留尽可能多的可选项。
充开发中。


当然,这并不意味着好的软件架构对系统的行为就没有影响了,事实上架 
其中的角色还是很111必的c 然 这 个 方 山 i，架构能起到的作用更多的时候是;' 的，修饰性的，并不n 卅J，山不肚必水川少的。”系统的架构设计中，琴J 系统行为的可选项少之又少。 匕販
软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构丁 
让系统便于理解、易于修改、方便维护，并且能轻松部署。软件架构的终极目标; 
是最大化程序员的生产力，同时最小化系统的总运营成本。 '

开 发 (Development)

一个开发起来很困难的软件系统一般不太可能会有一个长久、健康的生命周期 
所以系统架构的作用就是要方便其开发团队对它的开发。

这意味着，不同的团队结构应该采用不同的架构设计。一方面，对于一个只左 
五个开发人员的小团队来说，他们完全可以非常高效地共同开发一个没有明确定人 
组件和接口的单体系统(monolithic system)。事实上，这样的团队可能会发现聯二 架构在早期开发中反而是一种障碍。这可能就是为什么许多系统都没有设计一个良 
好架构的原因，因为它们的开发团队起初都很小，不需要设计一些上层建筑来限扔 
某些事情。

但另一方面，如果一个软件系统是由五个不同的团队合作开发的，而每个团入 
各自都有七个开发人员的话，不将系统划分成定义清晰的组件和可靠稳定的接口 
开发工作就没法继续推进。通常，如果忽略其他因素，该系统的架构会逐渐演射 
五个组件，一个组件对应一个团队。

当然，这种一个组件对应一个团队的架构不太可能是该系统在部署、运行以; 
维护方面的最优方案。但不管怎样，如果研发团队只受开发进度来驱动的话’W
的架构设计最终一定会倾向于这个方向。

部 署 (Deployment)

为了让开发成为孚效的工作，软件系统就必须是可部署的。在通常情况下，一 
个系统的部署成本越咼，可用性就越低。因此，实现一键式的轻松部署应该是我们 
设计软件架构的一个目标。

但很不幸，我们在系统的早期开发中很少会考虑部署策略方面的事情，这常常 
会导致一些易于开发、难于部署的系统架构。

例如，在系统的早期开发中，开发人员可能会决定采用某种“微服务架构”。 
这种架构的组件边界清晰，接口稳定，非常利于开发。但当我们实际部署这种系统 
时，就会发现其微服务的数量已经大到令人望而生畏，而配置这些微服务之间的连 
接以及启动时间都会成为系统出错的主要来源。

如果软件架构师早先就考虑到这些部署问题，可能就会有意地减少微服务的数 
量，采用进程内部组件与外部服务混合的架构，以及更加集成式的连接管理方式。

运 行 (Operation)

软件架构对系统运行的影响远不及它对开发、部署和维护的影响。*乎任何运 
行问霧囂囂增加硬件的方式来解决，这避免了软件架构的重新设计。

事实上，我 们 囂 嘗 通 囂 囂 蠶 的 器 蠶 器 个 囂 需 
囂囂蠶;的囂'愛件也远比人力要便宜,这也是软件架构对系统运行的影 
囂 没 規 对 开 发 、部署、维护的影响那么深远沪桶环剧牛的架构设计, 

当 然 ,这 并 不 是 豐 需 鷲 ;:上 蠶 駕 篇 盟 应 该 更 倾 向 第 统 
这样做是应该的，只是基于投入厅山比
H 
也 V ；；：构在整个系统运行的过程中十…


即使这样, s ’ r
就是一个设计良好的软件架构应该能明确地反1映该系统在运行时的需求。

也许我们可以换•个更好的说法，那就足设计良好的系统少'构应该可以使斤 
人员对系统的运行过程i 目了然。架构应％起到揭示系统运行过程的作用。具/ 说，就是i亥架构应该将系统中的用例、功能以及该系统的必备行为设置为对开麗 可见的一级实体，简化它们对于系统的理解，这将为整个系统的开发与维护槌； 
大的帮助。 

维 护 (Maintenance)

在软件系统的所有方面中，维护所需的成本是最高的。满足永不停歇的新斃 
需求，以及修改层出不穷的系统缺陷这些工作将会占去绝大部分的人力资源。
系统维护的主要成本集中在“探秘”和 “风险”这两件事上。其中，“爲 
(spelunking)" 的成本主要来自我们对于现有软件系统的挖掘，目的是确定新鷲 能或被修复问题的最佳位置和最佳方式。而 “风 险 ＜ risk ), 则是指当我们进行上 述修改时，总是有可能衍生出新的问题，这种可能性就是风险成本。

我们可以通过精雕细琢的架构设计极大地降低这两项成本。通过将系统切卅
组件，并使用稳定的接口将组件隔离，我们可以将未来新功能的添加方式明确出来 
并大幅度地降低在修改过程中对系统其他部分造成伤害的可能性。

保持可选项

正如我们在之前章节中所说的，软件有行为价值与架构价值两种价值。这其 
的第二种价值又比第一种更重要，因为它正是软件之所以“软”的原因。

软件被发明出来就是因为我们需要一种灵活和便捷的方式来改变机器聊亍: 
而软件的灵活性则取决于系统的整体状况、组件的布置以及组件之间的连搂八

那么到底哪些选项是我们应该保阳的？它们就是那些无关紧要的细节设计。

基本上，所有的软件系统部可以降解为策略打细节这两种匸要兀素。策略体现 
的是软件中所有的业务规则与操作过程，因此它是系统真正的价值所在。
而细节则是指那些让操作该系统的人、其他系统以及程序员们与策略进行交互,
但是又不会影响到策略本身的行为。它们包括I/O设备、数据库、Web系统、服务 器、框架、交互协议等。
软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并 
让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。
例如,
• 在开发的早期阶段应该无须选择数据库系统，因为软件的高层策略不应该关 
心其底层到底使用哪一种数据库。事实上，如果软件架构师足够小心，软件 
的高层策略甚至可以不用关心该数据库是关系型数据库，还是分布式数据库, 
是多级数据库，还只是一些文本文件而已。
在开发的早期阶段也不应该选定使用的Web服务，因为高层策略并不应该 知道自己未来要以网页形式发布。如果高层策略能够与HTML、AJAX、JSP、
JSF或任何Web开发技术脱钩, 那么我们就可以将对 Web系统的选择推迟 到项目的最后阶段。事实上，很有可能我们压根不需要考虑这个系统到底是 
不是以网页形式发布的。
在开发的早期阶段不应该过早地采用REST模式，因为软件的高层策略应该
与外部接口无关。同样的，我们也不应该过早地考虑采用微服务框架、SOA
科£架等。再说一遍，软件的高层策略压根不应该跟这些有关。
在开发的早期阶段不应过早地采用依赖注入框架(dependency injection framework), 因为高层策略不应该操心如何解析系统的依赖关系。 说到这里，我想读者应该明白我的意思了。如果在开发高层策略时有意地让自 
p je a a s体细节的纠缠,我们就可以将与具体实现相关的细韦决策推迟或延后,因 为爲爲的器我们就拥有越多的信息来做出合理的决策。
同时，这样做还可以让我们有机会做不同的尝试。例如。如果我们现在手里有架构整洁之道
一部分与数据豚无X：•的再丿吴策略，那么我们就川I 丿、川不同的数抑;咋來做实於 
验该系塔、d 仆Z 放抑;库Z 间的适应件和件能' % 似的帖况也応川「彳 种 Wch「 
甚至Web这种发布形式本身。 '嗪
另外.我们保留这些可选项的时间越长，实验的机会也就越多。 
多，我们做决策的时候就能拥有越充足的信息。
那么如果其他人已经替我们做岀了决策呢？譬如说，我们的公司已经指定了 
个数据库，或某种Web服务，或某个框架，这时应该怎么办？通常一个优秀的二 架构师会假装这些决策还没有确定，并尽可能长时间地让系统有推迟或修改/吃］ 
策的能力。 
7
一个优秀的软件架构师应该致力于最大化可选项数量。
设 备 无 关 性
如果想要找反映这方面思想的例子，我们还得先回到20世纪60年代。由于尝 
时的计算机行业还处于萌芽阶段，大部分程序员都来自数学专业，或者是其他工W 
类专业（当时超过三分之一的程序员是女性）。
当时,我们曾□Q 经犯过很多错误，而且还没有人知道那些是错误。当然了，耻
候我们怎么可能知道?
其中一个错误就是将代码与I/O设备直接紧密地绑定在一起。当时，如果難 
需要用打印机打印东西，就得专门写一段I/O指令来操作打印机，因此我们的代码 
是依赖于设备的。
例 如 '当我们要写一段要在电传打印机上输出的PDP-8程序时，需要用到附 
面这样一组机器指令：
PRTCHR? 0
TSF
JMP .-1
TLS
JMP I PRTCHR
这里的PRTCHR是电传打印机上十殳川來打印字符的子程序。首语句中的0是 
存储其返回地址用的（这里就不要细究这些了）。下来是TSF指令，它的作用是告 
诉电传三印机如果准备就绪，就跳过下一指令。如果电传打印机处于繁忙状态，就 
继续执行JMP・-1指令，也就是再跳转回tsf指令。一旦电传打印机处于就绪状态， T S F 就会跳转到TLS指令，该指令会将a 寄存器中保存的要打印的字符发送给电传 打印机。随后，JMP I PRTCHR指令会将程序返回给调用方。
一开始，这一策略工作起来完全没有问题。如果我们需要从读卡器中读取卡片,
我们就直接用代码与读卡器进行交互。如果我们需要在卡上打孔，就写一段代码直
接控制打卡的过程。整套程序运行得非常完美。我们当时怎么会知道这是一个错误
呢？
然而，管理大量的卡片是一件很麻烦的事。这些卡片可能会出现丢失、损坏、 
旋转、排序错误等问题。各部分的卡片都有可能丢失或混入多余的卡片，保持数据 
的一致性是当时的一大难题。
后来就岀现了磁带这种解决方案。它允许我们将原本打在卡片上的图像存储在 
磁带上。如果磁带不小心掉在地上，不会出现顺序被打乱的问题，我们也不会因此 
意外丢失记录，或者处理磁带时意外插入空白记录。显然，磁带是更安全的选择， 
而且它的读取和写入也更快，同时也很容易进行备份。
但不幸的是，我们当时所有的软件都是用于直接操作读卡器和打卡器的。为了 
让这些软件改用磁带，我们不得不花很大的力气重新修改代码。
到了 20世纪60年代末期，我们己经吸取了这个教训，并为此提出了设备无关 
性这个概念。当时的操作系统会将I/。设备抽象成打孔卡那样的，处理一条条记录 
的标准软件函数。我们写的程序会通过调用操作系统提供的服务来与抽象的记录处 
理函数进行交互。而系统运行人员可以将操作系统的抽象设备与具体的读卡器、磁 
带读取器以及其他类似的设备进行对接。
这 样 -来 ，同-段程序不经任何修改就既可以读/写卡片’也可以读/写磁带。开 
闭原则（OCP） 此时就诞生了 （当然，那时候还不叫这I 名字）。

垃圾邮件

们则负责编写程序为他们打印个人化的广告。
相信下面这些邮件读者一定不陌生。

H ello,马丁先生：
恭喜！
您是Witchwood Lane上唯一被选中参加我们仅有—次的特惠活动... 客户会给我们寄来一大卷信纸，其中的姓名和地址留空，其他文字都已经填好。 
我们的程序需要从磁带上读取姓名、地址等信息，然后将这些信息精确地打印在信 
纸上的对应位置。
这样的每一卷信纸里面有几千封信，重量近500磅，而且通常有数百卷之多, 
我们必须一封一圭寸地打印。
起初，我们使用的是IBM 360自带的单行打印机，它每个工作日可以打印几千 
张。但是，当时IBM 360每个月的租金要几万美金，成本太高了。
这时候，我们只需要让操作系统放弃单行打印机，改用磁带即可，我们的程序 
不需要做任何的改动，因为它们使用的是操作系统提供的抽象I/。设备接口。
而且IBM 360机器每10分钟就可以写满一卷磁带— 这一时间足够单行打印机 
打印几卷信纸了。然后这些磁带可以从计算机上取下，装载到离线打印机上进彳亍离 
线打印。当时我们有五台这样的打印机，它们可以7x24小时不停地工作，每周 打印儿十万封信。
可以
设 备 豊 甞 嚮 益 囂 篇 囂 牆 蠹 要 驚 暑 使 扌 黑
磁带卷上,并放到离线打印机匕进行批］止打印“
这段程序是有架构设计的，并且在设计屮实现了祐戻策略与底层实现细节的分 
离。其策略部分负责格式化姓名和地址,细节部分负贵操作具体的I/O设备。而我 
们具体采用哪个设备的决策是最后才做出的。

物理地址寻址

20世纪70年代早期，我曾为本地卡车工会编写过一套大型的账务系统。当时,
jin
A gent、Employer^ M ember这些记录都被存储在一块25MB大小的磁盘上。由 
于不同的记录尺寸不同，所以我们将磁盘的前几个柱面（cylinder）按 A g en t记录 的大小格式化每个扇区，中间的按Employer记录的大小格式化，最后几个柱面按 
照 Member记录的大小格式化。
当时我们编写的软件需要知道硬盘的具体结构。它知道每个硬盘包含200个柱
面，1 0 个磁头，每个柱面每个磁头有几十个扇区。它也知道哪些柱面上包含的是
A g en t记录，哪些柱面上包含的是Em ployer和 Member记录, 我们对所有的这些
都进行了硬编码。
另外，我们还在磁盘上保留了一个索引，以方便后续的记录查询。该索引也是 
通过一个特别的格式被存储到磁盘上的。譬如说，A gent记录的索引中每条记录包 
括 A g en t的 ID ,以及对应的柱面号码、磁头号码、扇区号码° E m ployer和 Member 
的索引也有类似的结构。其中，Member记录用一种双向链表结构存储在磁盘上。 每条Member记录都会包含前—个和后一个M e m b e r 记录所在的柱面号码、磁头号 
码、扇区号码。
在这种情况下，如果我们升级新硬盘会发生什么呢？新硬盘可能会有更多的磁 
头，更多的柱面，或是每个柱面有更多的扇区。这时候，我们就必须编写一介特姝 
的程序从旧磁盘读取数据，并将其写入新磁盘，同时换掉柱面、磁头、扇区的值。 
另外，我们还要修改代码中所有硬编码的部分一 -这样的代码到处都是! 毕竟我们 
所有的业务逻辑都和柱面、磁头、扇区的分配方案紧密地耦合在了一起。架构整洁之道
直到有-天，-位更有经验旳枉 
现逻辑时差点吐血，就像见到外星人 
我们改用相对地址方式来寻址。
汶W 月的同事建议我们将磁盘当成1 个扇区的线性队別来处理’用-串连续 
的 整 囂 幕 需 爲 址 。然后,我们可豐写= 需 盘 物 理 结 叭 
程序，以便将这些相对地址在线转换为柱面、磁头、扇区的S 马。
幸运的是，我们釆纳了他的建议。我们修改了系统的高层策略，使其与磁盘的 
物理结构脱钩。这样-来，我们就可以将具体选择哪种磁盘的决策从该应用程序中 
分离出来。

本章小结

在本章中，我们用两个小故事示范了一些架构师们普遍会采用的设计原则。优
秀的架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细
节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形 
式的依赖。另外，优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细 
节相关的决策，越晚做决策越好。