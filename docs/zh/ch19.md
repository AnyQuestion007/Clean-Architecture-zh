第 19 章 策略与层次

本质上，所有的软件都是一组策略语句的集合。是的，可以说计算机程序
不过就是一组仔细描述如何将输入转化为输出的策略语句的集合。

在大多数非小型系统（nontrivial system）中，翳体业务策略通常都可以被拆解
为多组更小的策略语句。一部分策略语句专门用于描述计算部分的业务逻辑，另一
部分策略语句则负责描述计算报告的格式。除此之外，可能还会有一些用于描述如
何校验输入数据的策略。

软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变
更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个
组件中。反之，变更原因、时间和层次不同的策略则应该分属于不同的组件。

架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个
节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之
间的依赖关系，它们将不同级别的组件链接起来。

这里提到的依赖关系是源码层次上的、编译期的依赖关系。这在 Java 语言中就
是指 import 语句，在 C# 语言中就是指 using 语句，在 Ruby 语言中就是指 require
语句。这里的依赖关系都是在编译过程中所必需的。

在一个设计良好的架构中，依赖关系的方向通常取决于它们所关联的组件层次。
一般来说，低层组件被设计为依赖于高层组件。

层次（Level）

我们对“层次”是严格按照“输入与输出之间的距离”来定义的。也就是说，
一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的
策略在系统中的层次是最低的。

在图 19.1 中，我们看到的是一个简单加密程序的数据流向图，该程序从输入设
备读取字符，然后用查表法转换这些字符'并将转换后的字符输出到输出设备。我
们将图中数据的流向用弯曲实心箭头标识了出来，而对于经精妙设计过的源码中的
依赖关系则使用直虚线来标识。

在 图 19.1 中，Translate 组件是这个系统中层次最高的组件，因为该组件距
离系统输入/输岀距离最远。

另外需要注意的是，图 19.1 中的数据流向和源码中的依赖关系并不总处于同一
方向上。这也是软件架构设计工作的一部分。我们希望源码中的依赖关系与其数据
流向脫钩，而与组件所在的层次挂钩。

但我们很容易将这个加密程序写成下面这样，这就构成了一个不正确的架构:

上面这个程序架构设计的错误在于，它让高层组件中的函数 ericrypt() 依赖于
低层组件中的函数 readChar() 与 writeChar()。

更好的系统架构设计应 如 图 19.2 所示。请 注 意 图 19.2 中被虚线框起来的
Encrypt 类及其两个接口 CharReader 和 CharWriter。所有的依赖关系都指向
了边界内部。这一切都说明它是系统中最高层次的组件。

在 图 19.2 中，ConsoleReader 和 Consolewriter 都属于具体类。由于它们
与输入/输岀最近’因此属于低层组件。

另外应该注意的是，这个架构将高层的加密策略与低层的输入/输出策略解耦了。
也就是说，当输入/输岀部分的策略发生变更时，它们不太可能会影响加密部分的策
略。

正如之前提到的，我们应该根据策略发生变更的方式来将它们分成不同的组件。
变更原因和变更时间相同的策略应在 SRP 和 CCP 这两个原则的指导下合并为同一
组件。离输入/输出最远的策略——高层策略——一般变更没有那么频繁。即使发生
变更，其原因也比低层策略所在的组件更重大。反之，低层策略则很有可能会频繁
地进行一些小变更。

例如，即使在这个简单的加密程序中，加密算法发生变更的可能性也要远小于
IO 设备发生变更的可能性。如果加密算法真的要变更，也很有可能比 I/O 设备的变
更更重大。

通过将策略隔离，并让源码中的依赖方向都统一调整为指向高层策略，我们可
以大幅度降低系统变更所带来的影响。因为一些针对系统低层组件的紧急小修改几
乎不会影响系统中更高级、更重要的组件。

从另一个角度来说，低层组件应该成为高层组件的插件。图 19.3 中的组件图展
示了这种关系,我们可以看到 Encryption 组件对 IODevices 组件的情况一无所
知，而 IODevices 组件则依赖于 Encryption 组件。

本章小结

综上所述，本章针对策略的讨论涉及单一职责原则（SRP）、开闭原则（OCP）、
共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽
象原则（SAP）。读者可以自行结合之前的内容来匹配每个原则所适用的场景以及
背后的原因。
