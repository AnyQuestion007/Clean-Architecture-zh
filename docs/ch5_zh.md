第5章
面向对象编程稍后我们会讲到，设计一个优秀的软件架构要基于对面向对象设计 
(Object-Oriented Design) 的深入理解及应用。但我们首先得弄明白-个问题:究竟 什么是面向对象？
对于这个问题，一种常见的回答是“数据与函数的组合”。这种说法虽然被广 
为引用,但总显得并不是那么贴切,因为它似乎暗示了 o .f()与 f(o )之间是有区 别的’这显然不是事实。面向对象理论是在1966年提出的，当时Dahl和 Nygaard 主要是将函数调用栈迁移到了堆区域中。数据结构被用作函数的调用参数这件事情 
远比这发生的时间更早。
另一种常见的回答是“面向对象编程是一种对真实世界进行建模的方式”，这
种回答只能算作避重就轻。 “对真实世界的建模”到底要如何进行？我们为什么要 
这么做，有什么好处？也许这句话意味着是“由于采用面向对象方式构建的软件与
真实世界的关系更紧密，所以面向对象编程可以使得软件开发更容易”—— 即使这
样说，也仍然逃避了关键问题 面向对象编1H1程究竟是什么?
还有些人在回答这个问题的时候，往往会搬出一些神秘的词语，譬如封装 
{encapsulation^、继 承 (inheritance)、多 态 (polymorphism)。其隐含意思就是说 面向对象编程是这三项的有机组合，或者任何一种支持面向对象的编程语言必须支 
持这三个特性。
那么，我们接下来可以逐个来分析一下这三个概念。
封装
导致封装这个概念经常被引用为面向对象编程定义的一部分。通过釆用封装特性， 
我们可以把一组相关联的数据和函数圈起来，便圈外血的代码只能看见部分函数， 
数据则完全不可见。譬如在实际应用中，类 (class)中的公共函数和私有成员变 
量就是这样。
然而，这个特性其实并不是面向对象编程所独有的。其实，c 语言也支持完整
33架构整洁之道
的封装，下面来看一个简单的c 程序：
point. h struct Point; struct Point* makePoint(double x, double y); double distance (struct Point ★pl, struct Point *p2);
point•c #include "point • hr, #include <stdlib•h> #include <math.h>
struct Point { double x,y;
struct Point* makepoint(double x, double y) { struct Point* p = malloc(sizeof(struct Point)); p->x = X； p_〉y = y; return p;
double distAnce (stiruct Point* pl f struct Point* p2) { double dx = pl->x 一 p2- 〉x; double dy = pl->y 一 p2->y; return sqrt(dx*dx+dy*dy);
}
_______________________________________________________________________________
显然，使用p o in t.h 的程序是没有P o in t结构体成员的访问权限的。它们只 
能调用makePoint ( ) 函数和d istan ce ()函数，但对它们来说，P o in t这个数据 
结构体的内部细节，以及函数的具体实现方式都是不可见的。
这正是完美封装 虽然C 语言是非面向对象的编程语言。上述C程序是很常
见的。在头文件中进行数据结构以及函数定义的前置声明(forward declare), 然后 在程序文件中具体实现。程序文件中的具体实现细节对使用者来说是不可见的。
而 C++作为一种面向对象编程语言，反而破坏了 c 的完美封装性第 5章面向对象编程
由于一些技术原因〔C++编译器要求类的成员变卅必须在该类的头文件中声明。 
这样一来，我们的point.h程序随Z 就改成了这样：
point•h class Point { public: Point(double x, double y)；
double distance (const Point& p) const;
private: double x; double y;
};
point ・ cc #include "point•hn
#include <math•h>
Point::Point(double xr double y) : x (x)， y (y)
{} 
double Point: :distance (const Point& p) const { double dx = x-p.x; double dy = y-p.y; return sqrt(dx*dx + dy*dy)；
好了，point.h文件的使用者现在知道了成员变量x 和 y 的存在！虽然编译器 会禁止对这两个变量的直接访问，但是使用者仍然知道了它们的存在。而且，如果
x 和 y 变量名称被改变了, point, cc也必须重新编译才行！这样的封装性显然是
不完美的。
当然，C++通过在编程语言层面引入public、private^ protected这些关 
键词，部分维护了封装性。但所有这些都是为了解决编译器自身的技术实现问题而
1 C++编译器必须要知道每个类实例的大小。
35架构整洁之道
引入的hack—— 编译器山j：技术实现原W 必须/I：•头文件屮看到成员变量的定义_ — 而 Java和 C#则彻底抛弃了头文件与实现文件分离的编程方式,这其实进一歩 削弱了封装性。因为在这些语言中,我们是无法区分 弘类的声明和定义的;I
由于上述原因,我们很难说强封装是面向对象编程的必要条件。而事实上,有 
很多面向对象编程语言|对封装性并没有强制性的要求。
面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实彳 
悟况是，那些声称自己提供面向对象编程支持的编程语言，相对于C 丿&种:M 
的语言而言，其封装性都被削弱了，而不是加强了。
继承
既然面向对象编程语言并没有提供更好的封装性，那么在继承性方面又如何 
呢？
嗯，其实也就一般般吧。简而言之，继承的主要作用是让我们可以在某个作用 
域内对外部定义的某一组变量与函数进行覆盖。这事实上也是c 程序员2早在面向对 
象编程i吾言发明之前就一直在做的事了。
卜面，看一下刚才的C 程序p o in t・h 的扩展版:
namedPoint.h struct NamedPoint;
struct NamedPoint* makeNamedPoint(double x, double y, char* name); void setName (struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);
namedPoint.c ^include "namedPoint,hu
1 例如 SmalltalkPython、JavaScriptLua^ Ruby。
2 不仅是C 语言，大部分同时期的编程语言都提供了将某种数据结构伪装成另外一种数据结构的特性。
36第 5章 向对象编程
#include <stdlib・h> struct NamedPoint { double xr y; char* name;
}；
struct NamedPoint* makeNamedPoint(double xr double yz char* n a m e ) ; struct NamedPoint* p = malloc(sizeof(struct NamedPoint)); p->x = X； p->y = y; p->name = name; return p；
)
void setName(struct NamedPoint* np, char* name) { 
np->name = name;
char* getName(struct NamedPoint* np) { return np->name;
} 
..
main . c 
小：•尽刁
#include "point.h" #include nnamedPoint ・ hH #include <stdio.h>
int main(int ac, char** av) {
struct NamedPoint* origin = makeNamedPoint(0O 0.0, "origin”) ； struct NamedPoint* upperRight = makeNamedPoint (1.0, 1.0, "upperRight");
printf(ndistance=%f\n"/ distance (
(struct Point*) origin, (struct Point*) upperRight));
}
请仔细观察main函数，这里NamedPoint数据结构是被当作Point数据结
37架构整洁之道
构的•个衍个体來使川的"Z 所以川以这样做，MM NamedPoint结构体的前 个成M的顺用与P o in t仙构休I丫八，个 7匕 汕 丫 说 ，Nam edPoint之所以可勺 
被伪装成P o in t来使用,是因为Nam edPoint足 P o in t结构体的•个超集,同 
两者共同成员的顺序也是一样的。 '
I 面这种编程方式虽然看上去有些投机取巧，但是在面向对象理论被提出/并 
这已经很常见了J 其实，C++内部就是这样实现单继承的。 ' *
因此，我们可以说，早在面向对象编程语言被发明之前，对继承性的支持处 
经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继昼: 
样便利易用，而且，多重继承(multiple inheritance)如果还想用这种方法来实圳,、 就更难了。 
‘
同时应该注意的是，在 m且i n .c 中，程序员必须强制将N am edPoint的参数K 型转换为P o in t,而在真正的面向对象编程语言中，这种类型的向上转换通常应彷 是隐性的。 
"
综上所述，我们可以认为，虽然面向对象编程在继承性方面并没有开创岀新,
但是的确在数据结构的伪装性上提供了相当程度的便利性。
回顾一下到目前为止的分析，面向对象编程在封装性上得0 分，在继承性上电 
强可以得0.5分 (满 分 为 1) O
下面，我们还有最后一个特性要讨论。
多态
在面向编程对象语言被发明之前，我们所使用的编程语言能支持多态吗?
答案是肖定的，请注意看下面这段用C 语言编写的copy程序：
1 这种编程方式到现在也很常见。第 5 章面向对象编程
#include <stdio ・ h>
void copy() { int c; while ( (c=getchar()) != EOF) putchar (c);
}
在上述程序中，函数getchar ()主要负责从STDTN中读取数据。但是STDLLN 究竟指代的是哪个设备呢？同样的道理,putchar ()主要负责将数据写入STDOUT, 而 STDOUT又指代的是哪个设备呢？很显然，这类函数其实就具有多态性，因为它 
们的行为依赖于STDIN和 STDOUT的具体类型。
这里的STDIN和 STDOUT与 Java中的接口类似，各种设备都有各自的实现。 
当然，这个C 程序中是没有接口这个概念的，那么getchar ()这个调用的动作是 如何真正传递到设备驱动程序中，从而读取到具体内容的呢？
其实很简单，UNIX操作系统强制要求每个10设备都要提供open、close> rwmd、write和 seek这 5 个标准函数。】也就是说，每个10设备驱动程序对这5 
种函数的实现在函数调用上必须保持一致。
首先，FILE数据结构体中包含了相对应的5个函数指针，分别用于指向这些函 
数：
struct FILE { void (★open) (char* name, int mode); void (*close)(); int (*read)(); void (*write) (char); void (*seek)(long index, int mode);
}；
然后，譬如控制台设备的10驱动程序就会提供这5个函数的实际定义，将 FILE
结构体的函数指针指向这些对应的实现函数:
1 UNIX系统有很多变体，这里只是举了一个例子。
39架构整洁之道
#include n file.hn
void open (char* name, int mode) {/★■■■*/} void close () {/★••」/} int read () {int c;/* ・..*/ return c;} void write (char c) {/★■•」/} void seek (long index 9 int mode) {/★•■■★/} struct FILE console = {open, close, read, write, seek};
现在,如果STDIN的定义是FILE*,并同时指向了 console这个数据结构, 那么getchar ()的实现方式就是这样的：
extern struct FILE* STDIN;
int getchar() { ieturn STDIN->read();
}
换句话说，getchar ()只是调用了 STDIN所指向的FIL E 数据结构体中的 
read函数指针指向的函数。
这个简单的编程技巧正是面向对象编程中多态的基础。例如在C++中，类中的 
每个虚函数(virtual function)的地址都被记录在一个名叫v ta b le 的数据结构里。 
我们对虚函数的每次调用都要先查询这个表，其衍生类的构造函数负责将该衍生类 
的虚的数地址加载到整个对象的v ta b le 中。
归根结底，多态其实不过就是函数指针的一种应用。自从20世纪40年代末期 
冯•诺依曼架构诞生那天起，程序员们就一直在使用函数指针模拟多态了。也就是 
说，面向对象编程在多态方面没有提出任何新概念。
当然了，面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多 
态变得更安全、更便于使用了。
、 用函数抬针显式实现彩态的问题就在于函数指针的危险性。毕竟，函数指针的 
豐 f 赖［［糸列跟人为遵守的约也仙;员必须严格按照固定约定来初始化函 如门针，并同样严格地按照约定来调用这些指针。只要有-个程序员没有遵守这戲约定!，整个程丿r 就会产生极其难以］|'|4踪利消除的itug°
第 5 章 面向对象编程
面向对象编程语言为我们消除「人匸遵岂这吐约朮的必要，也就幷「•消除了这 
方面的危险性。采川血向对象编程语言让q 态实现变得非常简单!让•个传统。程 序员可以去做以前不敢想的事情。综上所述，我们认为面向对象编程其实是对程序 
间接控制权的转移进行了约束。
多态的强大性
那么多态的优势在哪里呢？为了让读者更好地理解多态的好处，我们需要再来 
看一下刚才的copy程序。如果要支持新的IO设备，该程序需要做什么改动呢？譬 女口，假设我们想要用该copy程序从一个手写识别设备将数据复制到另一个语音合 
成设备中，我们需要针对copy程序做什么改动，才能实现这个目标呢？ 答案是完全不需要做任何改动!确实，我们甚至不需要重新编译该copy程序。 为什么？因为copy程序的源代码并不依赖于IO设备驱动程序的代码。只要10设 备驱动程序实现了 F IL E 结构体中定义的5 个标准函数，该 copy程序就可以正常 
使用它们。
简单来说，IO设备变成了 copy程序的插件。 为什么UNIX操作系统会将IO设备设计成插件形式呢？因为自20世纪50年代 
末期以来，我们学到了一个重要经验：程序应该与设备无关。这个经验从何而来呢？ 
因为一度所有程序都是设备相关的，但是后来我们发现自己其实真正需要的是在不 
同的设备上实现同样的功能。
例如，我们曾K1Q 经写过一些程序，需要从卡片盒中的打孔卡片1读取数据，同时要
通过在新的卡片上打孔来输出数据。后来，客户不再使用打孔卡片，而开始使用磁
带卷了。这就给我们带来了很多麻烦，很多程序都需要重写。于是我们就会想，如 
果这段程序可以同时操作打孔卡片和磁带那该多好。
打孔卡片，即IBM Hollerith卡,80格宽。虽然这种卡片在20世纪50年代、60年代,甚至70年代都 很常见，但是现在大部分人应该都没有见过了。架构整洁之道
插件式架构就是为了支持这种IO不相关性而发明的，它几乎在随后的所有 
系统中都有应用。但即便呂态有如此笔优点，大部分程序员还是没有将插件特 
入他们自己的程序中，因为函数指针实在是太危险了。
依赖反转
我们可以想象一下在安全和便利的多态支持岀现之前，软件是什么样子的。: 
面有一个典型的调用树的例子，
m a
in 函数调用了一些高层函数，这些高层函数; 用了一些中层函数，这些中层函数又继续调用了一些底层函数。在这里，源代低 
面的依赖不可避免地要跟随程序的控制流（详见图5.1） o
图5.1：源代码依赖与控制流的区别
如你所见,m ain函数为了调用高层函数，它就必须能够看到这个函数所在辭 
块。在 C 中，我们会通il# in c 丄u d e来实现，在 Java中则通过im port来实现 
在 C#中则用的是u sin g 语句。总乙 每个函数的调用方都必须要引用被调用别 在的模块。
显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为快越 
控制流，而控制流则决定了源代码依赖关系。
但一旦我们使用了多态，情况就不一样了（详见图5.2） o
42第5 章
--- —
面向对象编程
+F()
ML1
HL1 _______ 4
— 1>1
1
+F()
\
\ 
\
\
® 5.2：依赖反转
在图5.2中，模块HL1调用了 ML1模块中的F ()函数，这里的调用是通过源代 
码级别的接口来实现的。当然在程序实际运行时，接口这个概念是不存在的， HL1 
会调用ML1中的F ()函数-
请注意模块ML1和接口工在源代码上的依赖关系(或者叫继承关系)，该关系 
的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的 
影响是非常大的。
n i
事实上，通过利用面向编程语言所提供的这种安全便利的多态实现，无论我们 
面对怎样的源代码级别的依赖关系，都可以将其反转。
现在，我们可以再回头来看图5.1中的调用树，就会发现其中的众多源代码依 
赖关系都可以通过引入接口的方式来进行反转。
通过这种方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统 
中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者 
被调用，软件架构师都可以随意更改源代码依赖关系。
这就是面向对象编程的好处，同时也是面向对象编程这种范式的核心本质 
至少对一个软件架构师来说是这样的。
这种能力有什么用呢？在下面的例子中，我们可以用它来让数据库模块和用户
界面模块都依赖于业务逻辑模块(见图5・3) ，而非相反。
I 这种调用是隐性、间接进行的。
43架构整洁之道
图53：数据库和用户界面都依赖于业务逻辑
数据库
这意味着我们让用户界面和数据库都成为业务逻辑的插件。也就是说，业务乡 
辑模块的源代码不需要引入用户界面和数据库这两个模块。
这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件 
者部署单元（例如jai•文件、DLL文件、Gem文件等）了，这些组件或者部署单］ 的依赖关系与源代码的依赖关系是一致的，业务逻辑组件也不会依赖于用户界面和 
数据库这两个组件。
・■・
于是，业务逻辑组件就可以独立于用户界面和数据库来进行部署了，我们确 
户界面或者数据库的修改将不会对业务逻辑产生任何影响，这些组件都可以被分另 
独立地部署。
简单来说，当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不蟲 
要更改其他组件，这就是独立部署能力。
如果系统中的所有组件都可以独立部署，那它们就可以由不同的团队并行开戻 
这就是所谓的独立开发能力。
本章小结
面向对象编程到底是什么？业界在这个问题上存在着很多不同的说法和意肌 
然而对一个软件架构师来说，其含义应该是非常明确的：面向对象编程就是以縊 
为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以楸 
出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可必 
编译成插件，实现独立于高层组件的开发和部署。