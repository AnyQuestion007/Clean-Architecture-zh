第 13章 组件聚合

那么，究竟是哪些类应该被组合成一个组件呢？这是 个W常重要的设计決乗 
应该遵循优鸯的软件工程经齡來行事。但不幸的是，很多年以来，我们对于这么1 
要的决策经常是根据当卜而临的实际情况临时拍脑门决定的。 、
在本章中，我们会具体讨论以下三个与构建组件相关的基本原则：
• REP：复用/发布等同原则。
• CCP：共同闭包原则。
• CRP：共同复用原则。
复用/发布等同原则
软件复用的最小粒度应等同于其发布的最小粒度。
过去十年间，模块管理工具得到了长足的发展，例如Maven. Leiningen. RVM 等。这些工具日益重要的原因是正好在这十年间出现了大量可复用的组件和组件库 
应该说，我们现在至少已经实现了面向对象编程的一个原始初衷—— 软件复用。
REP原则初看起来好像是不言自明的。毕竟如果想要复用某个软件组件的话， 
—般就必须要求该组件的开发由某种发布流程来驱动，并且有明确的发布版本号。
这其中的一个原因是，如果没有设定版本号，我们就没有办法保证所有被复用 
的组件之间能够彼此兼容。另外更重要的一点是，软件开发者必须要能够知道这些 
组件的发布时间，以及每次发布带来了哪些变更。
只有这样，软件工程师才能在收到相关组件新版本发布的通知之后，依据该发
虫此，纽件的发布过榨还必须要能够产生适当的通知和发布文档，以便让它的用户 
根据这些信息做出有效的升级决策。
从软件设计和架构设汁的角度来看，rep原则就是指组件中的类与模块必须是 彼此紧密相关的。也就是说,•个组件; 
之间应该有…个共同的主题或者大方向。
92第 13章组件聚合
但从另外一个视角来看，这个原则就没那么简电了。因为根据该原则，一个组 
件中包含的类与模块还应该是可以同时发布的。这意味着它们共享相同的版本号与 
版本跟踪，并H•包含在相同的发行文档中，这些都应该同时对该组件的作者和用户 
有意义。
这层建议听起来就比较薄弱了 毕竟说某项事情的安排应该“合理”的确有点
假大空，不着实际。该建议薄弱的原因是它没有清晰地定义岀到底应该如何将类与 
模块组合成组件。但即使这样，REP原则的重要性也是毋庸置疑的，因为违反这个
原则的后果事实上很明显-----定会有人抱怨你的安排“不合理”，并进而对你的 
软件架构能力产生怀疑。
而且，REP原则的上述薄弱性也会由以下两个原则所补充。CCP和CRP会从相 
反的角度对这个原则进行有力的补偿。
共同闭包原则
我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个
组件中, 而将不会同时修改，并且不会为了相同目的而修改的那些类放至U
不同的组件中。
这其实是SRP原则在组件层面上的再度阐述。正如SRP原则中提到的“一个类 
不应该同时存在着多个变更原因” 一样，CCP原则也认为一个组件不应该同时存在 
着多个变更原因。
对大部分应用程序来说，可维护性的重要性要远远高于可复用性°如果某程序 
中的代码必须要进行某些变更，那么这些变更最好都体现在同一个组件中，而不是 
分布于很多个组件中打因为如果这些变更都集中在同一个组件中，我们就只需要重 
新部署该组件，其他组件则不需要被重新验证、重新部署了。
总而言之，CCP的主要作用就是提小我们岌将肪有可能会被一起修改的类集中
1 请参阅第27章 “服务：宏观与微观”中的“运送猫咪的难题” °
93ML：
爲 雷 以 ;沁 降 低 冈 软 件 I、⑹皿部署咖来的工作压儿
另 外 C C P 原则和开闭原则(OCP)也是紧密相关的。C C P 讨论的就是ocp 中所指的••闭包•’ I O C P 原则认为-个类应该便于扩展，而抗拒修改。由于叽 
的闭包是不可能的，所以我们只能战略性地选择闭包范围。在设讣类的时候，护 
需要根据历史经验和预测能力，尽可能地将需要被一同变更的那些点聚合在魂
对于CCP,我们还可以在此基础上做进一步的延伸，即可以将某'类变更所彷 
及的所有类尽量聚合在一处。这样当此类变更出现时，我们就可以最大限度地做£ 
使• • 该类变更只影响到有限的相关组件。
与 SR P原则的相似点
如前所述，C C P 原则实际上就是SRP原则的组件版。在 S R P 原则的指导下， 
我们将会把变更原因不同的函数放入不同的类中。而 CCP原则指导我们应该将变更 
原因不同的类放入不同的组件中。简而言之，这两个原则都可以用以下一句简短的 
话来概括：
将由于相同原因而修改，并且需要同时修改的东西放在一起'将由于 
不同原因而修改，并且不同时修改的东西分开。
共同复用原则
不要强迫一个组件的用户依赖他们不需要的东西。
共同复用原则(CRP)是另外一个帮助我们决策类和模块归属于哪-个组件的 
八贝I ° 该原则建议我们将经常共同复用的类和模块放在同一个组件中。 
用 的 需 爲 說 豐 蔦 驚 警 的 情 况 是 多 个 类 同 时 作 为 某个豊第43章组件聚合
・ ・— ■■- — — ■ ・ F • " ■ I * ~*
一个简单的例子就是容器类I j比相关的遍丿丿丿器类，这些类Z 间通常是紧密相关 的，一般会被共同复用，因此应该被放置在同一个组件中。
但是CRP的作用不仅是告诉我们应该将哪些类放在 •起，更重要的是要告诉我
们应该将哪些类分开。因为每当一个组件引用了另一个组件时, 就等于增加了一条
依赖关系。虽然这个引用关系仅涉及被引用组件中的一个类，但它所带来的依赖关 
系丝毫没有减弱。也就是说，引用组件已然依赖于被引用组件了。
由于这种依赖关系的存在，每当被引用组件发生变更时，引用它的组件一般也 
需要做出相应的变更。即使它们不需要进行代码级的变更，一般也免不了需要被重 
新编译、验证和部署。哪怕引用组件根本不关心被引用组件中的变更，也要如此。
因此，当我们决定要依赖某个组件时，最好是实际需要依赖该组件中的每个类。 
换句话说，我们希望组件中的所有类是不能拆分的，即不应该出现别人只需要依赖 
它的某几个类而不需要其他类的情况。否则，我们后续就会浪费不少时间与精力来 
做不必要的组件部署。
因此在CRP原则中，关于哪些类不应该被放在一起的建议是其更为重要的内容。 
简而言之，CRP原则实际上是在指导我们：不是紧密相连的类不应该被放在同一个 
纟日件里C
与 ISP原则的关系
C R P 原则实际上是1SP原则的一个普适版。ISP原则是建议我们不要依赖带有 
不需要的函数的类，而CRP原则则是建议我们不要依赖带有不需要的类的组件。
不要依赖不需要用到的东西。
组件聚合张力图
读到这里，读者可能己经意识到上述三个原则之间彼此存在着竞争关系。M P架构整洁之道
和 CCP原则是黏合性原则，它们会让•组件变得更大,而CRP原则是排除性原则, 
它会尽量让组件变小卜：件架构师的任务就是要/门去三个原则中间进行取舍。
下面我们来看一下图13.1。这「 张组件聚合三大原则的张力图图的垃线所 
描述的是忽视对应原则的后果。
太务不必要的发布
织件在这个区域中如何定位?
图 13」：组件聚合原则的张力图
简而言之，只关注REP和 CRP的软件架构师会发现，即使是简单的变更也会 
同时影响到许多组件。相反，如果软件架构师过于关注CCP和 REP,则会导致很多 
不必要的发布。
优秀的软件架构师应该能在上述三角张力区域中定位一个最适合目前研发团队 
状态的位置，同时也会根据时间不停调整。例如在项目早期，CCP原则会比REP原 
则更重要，因为在这一阶段研发速度比复用性更重要。
曰一般來说，一个软件项目的重心会从该三角区域的右侧开始，先期主要牺牲的 
是复用性。然后，随着项目逐渐成熟，其他项目会逐渐开始对其产生依赖，项目重
1 感谢Tom Ottinger最先提出这个想法。
96第 43章 组 件 聚 合
心就会逐渐向该二角区域的左侧滑动。换句话说， .个项”在组件结构设计上的重 
心是根据该项目的开发时间和成熟度不断变动的，我们对组件结构的安排主要与项 
目开发的进度和它被使用的方式有关，与项目本身功能的关系其实很小。
本章小结
过去，我们对组件在构建过程中要遵循的组合原则的理解要比REP、CCP、CRP
这三个原则更有限。我们最初所理解的组合原则可能完全基于单一职责原则。然而， 
本章介绍的这三个原则为我们描述了一个更为复杂的决策过程。在决定将哪些类归 
为同一个组件时，必须要考虑到研发性与复用性之间的矛盾，并根据应用程序的需 
要来平衡这两个矛盾，这是一件很不容易的事。而且，这种平衡本身也在不断变化。 
也就是说，当下适用的分割方式可能明年就不再适用了。所以，组件的构成安排应 
随着项目重心的不同，以及研发性与复用性的不同而不断演化。第44章 
组件耦合
0 的圧