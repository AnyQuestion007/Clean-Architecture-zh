第33章架构整洁之道
现在是时候将所有的这些设计规则和架构理念整合起来C 卜面’我们来做- 
次案财析，这个案例分析虽枷简黠但可以描述清楚f i 秀的系统架构. 
设计过程和设计决策中应该如何行事。
产品
在这个案例分析中，我要讲的是一个我自己很熟悉的产品：线上收费视频网站。 
当然，这个有点像cleancoders.com,我在这个网站上出售我的软件开发教程視 
频。
这个案例的设计很简单，就是我们打算向一些个人或者企业提供一批收费的线 
上教学视频。个人用户既可以选择在线支付之后直接在线观看视频，也可以选择付 
-笔更高的费用将视频下载到本地，永久地拥有它们。而企业用户就只能在线播放， 
但他们可以选择批量购买，以此来获得一定折扣。
个人用户通常既是购买者又是观看者。而企业用户则不同，他们购买视频通常 
是用来给其他人观看的。
视频作者需要负责上传视频文件、写简介，并且提供视频附带的一系列习题、 
课后作业、答案、源代码以及其他各类资料。
管理员需要负责增加新的视频播放列表，往视频播放列表里添加和删除视频,
并且为各种许可类型设置价格。
系统架构设计中的第一步，是识别系统中的各种角色和用例。
用例分析
下面，我们通过图33」来示范一次典型的用例分析。
258■
图33」：典型的用例分析
如你所见，图中显然存在着四个角色。根据单一职责原则（SRP），这四个角 
色将成为系统变更的主要驱动力。每当添加新功能，或者修改现有功能时，我们所 
做的一切都是在为这些角色服务。所以我们希望能够对系统进行分区处理，避免其 
中一个角色的变更需求影响其他角色。
另 外 图 33 1 中的用例并不是一个完整的列表。例如’这里没有分析用于执行 
登录、注销的用例。省略它们的原因很简单，为了控制本H篇幅。如果列出所有的 
用例，这一章就会变成一本单独的书了。
R 舟 '才右一此用常线框起来的用例。我们称之为抽象用
读者应该注意到图33.1中 还 有 些 用 叫 世 5 "
259架构整洁之道
例 ］,
中，
它们通常用来负责设置通用策略，然后交由其他具体用例来使用。譬如在该图 
“查看目录”这个用例同时被"购买者查看目录”和 “观看者查看目录”这两
个用例所继承并实现。
-方面来说，其实这种抽象并不是必需的。如果没有这「层拥象：整个产品并 
不会受到影响；但是另一方面来说，由于这两个用例十分相近，我认为以果种方式
来将它们合并起来分析是很合理的。
组件架构
既然我们弄清楚了系统中的各种角色和用例，接下来就可以构造一个初步的组 
件架构图了（如图33.2所示）。
' 囂 舄 霧 遵 囂 翥 囂 跖 需 需 么 豐 严 的 《叽心这种原型符号更标准-些,但
260第33章 案例分析：视频销售网站
展示器(C atalog P re s e n te r)。这就是我应对查看目录列衣这个抽象用例的方 
法。我假设这些视图和展示器将会被编写为抽象类，而继承它们的组件将会包括它 
们的派生类。
但问题是，我们真的需要将系统拆分成这么多组件，然后以.ja r 或.d l l文件 的形式一个个交付吗？是，又不全是。我们确实要按照组件将编译和构建环境分开， 
以便单独构建对应的组件。但我们仍然可以考虑将所有的交付单元组合起来交付， 
例如，根据图33.2中的分组，我们可以很简单地将它们交付为5 个.j a r 文件—— 视图、展示器、交互器、控制器和工具类，这样就可以分别单独部署这些被修改的 
组件了。
除此之外,还有另一种分组方式，就是将视图和展示器放在同一个• j a r 文件中， 而将交互器、控制器以及工具类各自放在独立的・j “r 文件中。还有一种更简单的方 式，就是将视图和展示器放在—个小匸文件中，而将其他所有的组件合并为另一 
个・j a r 文件。
依赖关系管理架构整洁之道
, 而且都指向包含更高级策略的组件。
....意一下图中的“使用”关 系 （开放箭头），它和控制流方向是
（闭合箭头）则与之相反，它反映的是我们对开闭原则的 
通过调整依赖关系，可以保证底层细节的变更不会影响到高层策略组件。
是同一个方向
另外，还应该注j —致的；而"继承"关系 
应用，
本章小结
图33.2中的架构实现的是两个维度上的隔离。第一个是根据单一职责原则对所 
使用的系统的各个角色进行了隔离，第二个则是对依赖关系原则的应用。这两个维 
度的隔离都是为了将不同变更原因和不同变更速率的组件分隔开来。譬如变更的原 
因不同是因为组件使用的角色不同，而变更速率则取决于组件所在的层级。
按照这样的方式组织代码的结构，我们就可以在部署时做灵活的选择。可以随 
时将组件整合部署，也可以在要求变化的时候灵活地调整。
262呜 饗
uoul-s
私
S
，京
€
!
■
!
1
=
三
|
£
枣
£
 j
殳
1
$
$
|
扌辛？傷後
*§
辛字佞殳專
f i f f
 E
F
E
B
S
B
B
K
E
E
K
2
蟲
M架构整洁之道
根据本书之前给出的所冇建议，相侑读秤一定能够建构出具有良好边界设计的 
类和组件，以形成清晰的责任划分以及可控的依赖关系'设讣出更好的软件了。但 
是困难之处彳扌往在于细节z 中， •旦疏忽,也仃对能会对软件质量造成不良影响。 下面我们再来看一个例子,假设正在构建- 个在线卩店，这个例子的任务是实 
现•个客户査看订单状态的用冲 虽然这是—个卜程序的示例,但具所示〔的原 
理适用于任何语言。现在，i上我们暂时将整洁架构的概念放在一必’先來看•卜如 何具体安排代码设计和代码结构。
按层封装
我们首先想到的，也可能是最简单的设计方式，就是传统的水平分层架构。在 
这个架构里，我们将代码从技术角度进行分类。这通常被称为“按层封装”。图34.1 
用 UML类图展示了这种设计。
在这种常见的分层架构中，Web代码分为一层，业务逻辑分为一层，持久化是 另外一层。换句话说，我们对代码进行了水平分层，相同类型的代码在一层。在“严 
格的分层架构”中，每一层只能对相邻的下层有依赖关系。在 Java中，分层的概念 通常是用包来表示的。如图34.1所示，所有的分层（包）之间的依赖关系都是指向 
下的。这里包括了以下Java类。
• O rd e rsC o n tro lle r： Web控制器，类 似 Spring MVC控制器，负责处理 Web请求。
• O rderS ervice：定义订单相关业务逻辑的接口。
• O rd erS erv icelm p l： Order服务的具体实现 • O rdersR epository：定义如何访问订单持久信息的接口。 • JdbcO rderR epository：持久信息访问接口的实现。
1 这其实是种特别糟糕的命名方式，但是如同下文所说，这真的不算什么。第 34章 拾 遗
r
 • 妝筲立童中Martin Fowler声称釆用这种 分 层 爲 益 錶 t 寫 轟 篇 二 并 不 缺 乏 拥 戴 者 。很多书籍、窗 代
1 网址为 https://niartinfbwSin/bliki/PTationDomainDatgmng・html
265架构整洁之道
码示范都在教育你采用分柴架构° 
这种方式在顶丨…
指出的那样・
讪初期Z 所以会很介适,是因为它不会过于复杂。_但就像Manln
但软件规模扩展了，我们很快就会发现将代码势为
需要进一步进行模块化。
匸 仏 所 说 「这里述存在另外■个间分从架构无法展现具体的业务领域 
■ I 併个不同业务领域的、I 是都采川了分层架构的代码进彳/比，你会发现 
它们的相似程度极高：都有Web层、服务层和数据仓库层。这是分层架构的另外-个问题，后文会具体讲述。
按功能封装
另外_ 种组织代码的形式是“按功能封装”，即垂直切分，根据相关的功能、 
业务概念或者聚合根（领域驱动设计原则中的术语）来切分。在常见的实现中，所 
有的类型都会放在一个相同的包中，以业务概念来命名。
图 34.2展示了这种方式，类和接口与之前类似，但是相比之前，这次它们都被 
放到了同一个Java包中。相 比 “按层封装”，这只是一个小变化，但是现在顶层代 码结构至少与业务领域有点相关了。我们可以看到这段代码是与订单有关的，而不 
是只能看到Web、服务及数据访问。另外一个好处是，如果需要 修 改 “查看订单” 这个业务用例，比较容易找到相关代码，毕竟它们都在一个包中，而不是分散在各
软件研发团队常常一开始采用水平分层方式（即 “按层封装”）, 遇到困难后 
冉切换到垂」」1分层方式（即 “按功能封装”）。我认为，两种方式都很不好。看完 
本书，你应该意识到还有更好的分类方式—— 没错。
'器常总鳥脇他駕总議但— 在推山
266®
3
4
・
2
:
W
3
4
郦
o 『 d e r s c o n = o = e r
A A U S e s w
o r d e r s s e r v o e - m p -
< d r d e r f a c e v v
O r d e r s R e p o s i t o r y
J d b c o
s .
e r s R e p o » i o r y
c o m
・ m v c o m p a n y ・ m y a p p ・ o r d e r s
2 6 7端口和适配器
如Bob大叔所说,通过采用“端口和适配器… 六边形架构”“边界、控制器、 实体“等，我们可以创造出一个业务领域代码与具体实现细巾（数据斥、框架等） 
隔离的架构。总结卜來，如图34.3所示，我们可以区分出代码中的内部代码（领域, 
Domain）与外部代码（基础设施‘ Infrastructure）。
图34.3：区分内部代码和外部代码
内部区域包含了所有的领域概念，而外部区域则包含了与外界交互的部分（例 
如 UI、数据库、第三方集成等）。这里主要的规则是，只有外部代码能依赖内部代 
码，反之则不能。图34.4展示了 “查看订单”这个业务用例是如何用这种方式实现 
的。 匚厂
这里com. mycompnay. myapp . dom ain包是内部代码，另外一个包是外部代 
码 。注意这里的依赖关系足由外向内的。眼尖的读者可以注意到之前的 
O rderR epository类现在被改名为o rd e rs o 这个概念基于领域驱动设计理念， 
只中芟求内部代码都应该用独特的领域语言来描述。换句话说，我们在业务领域 
面讨论的应 该 是 O rd ers，而 不 是 "OrdersRepository"。
I: