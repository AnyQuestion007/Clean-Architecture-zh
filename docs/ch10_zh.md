第 40章第 40章 IS P :接口隔离原贝I」
接口隔离原则(1SP) ”这个名字來自图10」所示的这种软件结构。
图 10.1：接口隔离原则
在图10.1所描绘的应用中，有多个用户需要操作OPS类。现在，我们假设这里 
的U s e d 只需要使用opl, User2只需要使用op2, User3只需要使用op3。
在这种情况下，如果OPS类是用Java编程语言编写的，那么很明显，Userl 虽然不需要调用op2、oP 3,但在源代码层次上也与它们形成依赖关系。这种依赖意 味着我们对OPS代码中op2所做的任何修改，即使不会影响到Userl的功能，也 会导致它需要被重新编译和部署。
这个问题可以通过将不同的操作隔离成接口来解决，具体如图10.2所示。
同样，我们也假设这个例子是用Java这种静态类型语言来实现的，那么现在 Userl的源代码会依赖于UlOps和 opl,但不会依赖于OPS。这样一来，我们之后 对 OPS做的修改只要不影响到userl的功能，就不需要重新编译和部署Userl 了。
图 10.2：接口隔离
75架构整洁之道
ISP与编程语言
很明显，上述例子很大程度上也依赖于我们所釆用的编鷲：对 于 叫 
的静态类型语言来说，它们需要程序员显式地C ：；t ' 爲 : 嚣 Wde其螂 功能所需要的源代码。而正是这些语句带来了源代码乙间的依赖关系'馳就關 
了某些模块需要被重新编译和重新部署。
而对于Ruby和 Python这样的动态类型语言来说，源乎码中就不存在这样册 明，它们所用对象的类型会在运行时被推演出来，所 以也就不存在强制重新编琳 
重新部署的必要性。这就是动态类型语言要比静态类型语言更灵活、耦合度更松的 
原因。
当然，如果仅仅就这样说的话，读者可能会误以为1SP只是一个与编程语言的
选择紧密相关的设计原则，而非软件架构问题，这就错了。
ISP与软件架构
回顾一下ISP最初的成因：在一般情况下，任何层次的软件设计如果依赖于不 
需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的 
重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。
例如，我们假设某位软件架构师在设计系统s 时，想要在该系统中引入某个矗 架 F。这时候，假设框架F 的作者又将其捆绑在一个特定的数据库D 上，那么就% 
成 r S 依赖于F, F 又依赖于D 的 关 系 （参 见 图 10 3 ） 系 统 S 框 架 F 数 据 库 D
图 10.3：有问题的软件架构 -------------- - - -
不 需 眾 霊 对 篇 豊 蠶 : 蕙 需 需 囂 囂 囂 同 炸
76第 10章 IS P :接口隔离原则
致 S的重新部署。更糟糕的是，D 中一个无关功能的错误也可能会导致F和S运行 
出错。
本章小结
本章所讨论的设计原则告诉我们：任何层次的软件设计如果依赖了它并不需要
的东西，就会带来意料之外的麻烦。
我们将会在第13章“组件聚合”中讨论共同复用原则的时候再来深入探讨更多 
相关的细节。