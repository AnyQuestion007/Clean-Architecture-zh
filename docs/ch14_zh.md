第 44章组件耦合
接下来要讨论的［条原则主要关注的是组件之间的关系。在这些原则中,我们 
同样会面临着研发能力和逻辑设甘之间的冲突。平竞,影响组件结构的不仅有技术 
水平和公司内部政治斗争这两个因素，其结构本身更是不断变化的。
无依赖环原则
组件依赖关系图中不应该出现环。
我们一定都有过这样的经历：当你花了一整天的时间，好不容易搞定了一段代 
码，第二天上班时却发现这段代码莫名其妙地又不能工作了。这通常是因为有人在 
你走后修改了你所依赖的某个组件。我给这种情况起了个名字—— “一觉醒来综合 
征”。
这种综合征的主要病因是多个程序员同时修改了同一个源代码文件。虽然在规
模相对较小、人员较少的项目中, 这种问题或许并不严重，但是随着项目的增长,
研发人员的增加，这种每天早上刚上班时都要经历一遍的痛苦就会越来越多。甚至 
会严重到让有的团队在长达数周的时间内都不能发布一个稳定的项目版本，因为每 
个人都在不停地修改自己的代码，以适应其他人所提交的变更。
在过去几十年中，针对这个问题逐渐演化出了两种解决方案，它们都来自电信 
行业。第一种是“每周构建” ‘第二种是“无依赖环原则（ADP） ” °
每周构建
每周构建方案是中型项目中很常见的一种官理手段。其具体做法如下：在母周 
的前四天中，让所有的程序员在自己的私有库上工作，忽略其他人的修改，也不考 
虑互相之间的集成问题；然后在每周五要求所有人将自己所做的变更提交，进行统 
一构建。架构整洁之道
而且更不幸的是,随着项目越来越大，每周五的集成I•作会越來越难以按时完 
成。而随着集成仆与也來址电，丿"、的丿川山卄越和也频繁-经丿丿丿过几次这样 
的加班Z I., •沱〉、仃人卅皿2 灿 则 I 并血曲川期四丿「始，就这样一步一步地， 
I :成匸n -慢慢地就要占用掉总不多半周p勺时间°
事实上,这个问题最终还会造成更大的麻烦。因为如果我们想歩保持高敛率g 开发，就不能颂繁地进彳亍构建操作，但是如果我们减少了构建次数，延扶了项日妙 
左的时间间隔，又会彤响到该项目的质量，增大它的风险。整个项目会少得越少 
越难以构建与测试，团队反馈周期会越来越长，研发质量自然也会越来越差。
消除循环依赖
对于上述情景，我们的解决办法是将研发项目划分为一些可单独发布的组件， 
这些组件可以交由单人或者某一组程序员来独立完成。当有人或团队完成某个组件 
的某个版本时，他们就会通过发布机制通知其他程序员，并给该组件打一个版本号， 
放入一个共享目录。这样一来，每个人都可以依赖于这些组件公开发布的版本来进 
行开发，而组件开发者则可以继续去修改自己的私有版本。
每当一个组件发布新版本时，其他依赖这个组件的团队都可以自主决定是否立 
即采用新版本。若不采用，该团队可以选择继续使用旧版组件，直到他们准备好采 
用新版本为止。
■■■
这样就不会出现团队之间相互依赖的情况了。任何一个组件上的变更都不会立 
刻影响到其他团队。每个团队都可以自主决定是否立即集成自己所依赖组件的新版 
本。更重要的是，这种方法使我们的集成工作能以一种小型渐进的方式来进行、.e 序员们再也不需要集中在一起，统一集成相互的变更了。
* 如你所见，上述整个过程既简单又很符合逻辑，因而得到了各个研发团队的广 
泛采用。但是，如果想要成功推广这个开发流程，就必须控制好组件之间的依赖结 
构，绝对不能允许该结构中存在着循环依赖关系。如果某项目结构中存在着循环枚 
赖关系，那 么 “一觉醒来综合征”将是不可避免的。
100第14章组件耦合
、、 下面让我们来看看图14.1,该图展示了一个典型应用程序的组件结构。当然， 
这个应用程序的具体功能与我们要讨论的无关,真正重要的是其组件之间的依赖结 
构。我们应该口丁以注意到，该组件依赖结构所呈现的是一个有向图，图中的每个节 
点都是一个项目组件，依赖关系就是有向图中的边“
更重要的是，不管我们从该图中的哪个节点开始，都不能沿着这些代表了依赖 
关系的边最终走回到起始点。也就是说，这种结构中不存在坏，我们称这种结构为 
有向无环图（Directed Acyclic G m ph,简写为 DAG）。
图 14.1：
现在，如果负责P re se n te rs组件的团队需要发布一个新版本，我们就应该很 容易判断出哪些组件会受这个变更的影响 只需要按其依赖关系反向追溯即可。
显然在图14・「中，View和 M ain是同时会被影响的两个组件。这两个组件的研发 团队需要决定是否采用P re se n te rs组件的新版本° 另外值得注意的是，当 - i n 组 件 发 布 新 版 本 袞 葺 豐 中 的 其 鷲 葺 : 就没有影响，既没有-个组件依赖于M a"，也 警 驚 驚 关 霊 益 囂 ; 囂 的变更。这太好了，至少表示我们在发布M a "的新版本时，口」以不必j 虑匕对整 
个项目微乎其微的影响。
101架构整洁之道
的 Presenters 和 Interact ors
其他组竹h 需要做任何修改c这可以讣编写Presenters 试时号虑更少的变匸作量更小。
当Present prs细fl的押丿们需寒进行•次测试时，他们只需 及 Entities的沟前版本一起构了 组件的程序员们在
为我们需要发布幣个系统时，可以让整个过程从卜•至匕来戏行。貝体茫兑卄 
肖先对Entities组件进行编译、测试、发布。随后是Database和 " 匕 ; J 这 两 个 组 件 。冉 紧 随 其 后 的 是 Presenters > View > Control [»宀 Authorizer四个组件。最后是Mmin组件。这样一来，整个流程会IE常高晰 2 氛只要我们了解系统各部分之间的依赖关系，构建整套系统就会变牛
循环依赖在组件依赖图中的影响
假设某个新需求使我们修改了 Entities组件中的某个类，而这个类对竝 Authorizer组 件 中的某个类。例 如 ，Entities组 件 中 的 User类使潜 Authorizer组件中的Permissions类。这就形成了一个循环依赖关系，如冬 
所示。
图 14.2；循环依赖序员囂需驚囂就畫合我们的项目带来麻烦。例如,当Database组件的程 组件就必须也要与Authorizer组件兼容，而 A u t h o r i z e r 鷲 : 驚 ' E c t o r s 组件。这样一来，Database组件的发布就会变得非 
° ' Entities、Authorizer 及 Interactors 这三个组件事实上
被口并成］- I更大的组件。这些组件的程序员现在会互相形成干扰，因为他们在 
开发中都必须使用完全相同的组件版本c 这还只是问题的冰山一角，请想象一下我们在测试Entities组件时会发生什 么？'冃况2 让人触目惊心我们会发现自己必须将Authorizer和工nteractors 
集成到一起测试。即使这不是不能容忍的事，但至少这些组件之间的耦合度也是非 
常令人不安的。
很显然，这样一个小小的测试必须要依赖大量的库就是因为其组件结构依赖图 
中存在的这个循环依赖。这种循环依赖会使得组件的独立维护工作变得十分困难。 
不仅如此，单元测试和发布流程也都会变得非常困难，并且很容易出错。此外，项 
目在构建中岀现的问题会随着组件数量的增多而呈现出几何级数的增长。
所以，当组件结构依赖图中存在循环依赖时，想要按正确的顺序构建组件几乎 
是不可能的。这种依赖关系将会在Java这种需要在编译好的二级制文件中读取声明 
信息的语言中导致一些非常棘手的冋题。
打破循环依赖
. 当然,我们可以打破这些组件中的循环依赖，并将其依赖图转化为dag。目前 有以下两种主要机制可以做到这件事情。
1 应 用 依 赖 反 譽 囂 ; 豐 囂 ，' 黑 豊 豐 烏 爲 豐 
黑 器 囂 豐 与 A u th o rizer之间的依赖关系反转了，自然也就打破了循环 
依赖关系。
103架构整洁之道
Entities Authorizer
User
---------T>n
> Permissions v
Permissions
图 14.3: 将 Entities与 Authorizer之I可的依赖关系反转
2.创建一个新的组件，并让Entities与 Authorize这两个组件轨：- 
它。将现有的这两个组件中互相依赖的类全部放入新组件（如图14.4所示）.
“抖动”
当然，采用第二种解决方案也意味着在需求变更时，项目的组件结构;:; 
变更。确实是这样的，随着应用程序的不断演进，其组件结构也会不停地卜'第44章组件耦合
张:因此，、我［］必弓要持续地监控顶目中的循环依赖关系。当循环依赖出现时，必 
须以某种力式消除它们。为此，我们有时候不可避免地需要创建新的组件，而使整 
个组件结构变得更大。
自上而下的设计
根据上述讨论，我们可以得出一个无法逃避的结论：组件结构图是不可能自上 
而下被设计出来的。它必须随着软件系统的变化而变化和扩张，而不可能在系统构 
建的最初就被完美设计出来。
有些读者可能会觉得这个结论有些反直觉。人们通常会直观地认为，代表项目 
粗粒度的结构单元，也就是组件，应该与顶层设计中的功能单元是相对应的。
同样的，人们也普遍认为项目粗粒度的组件分组规则所产生的就是组件的依赖 
结构，也应该在某种程度上与项目的系统功能分解的结果相互对应。但是很明显， 
组件依赖关系图其实不具备这样的属性。
事实上，组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序 
在构建性与维护性方面的一张地图。这就是组件的依赖结构图不能在项目的开始阶 
段被设计岀来的原因—— 当时该项目还没有任何被构建和维护的需要，自然也就不 
需要一张地图来指引。然而，随着早期被设计并实现岀来的模块越来越多，项目中 
就逐渐出现了要对组件依赖关系进行管理的需求，以此来预防“一觉醒来综合征” 
的爆发。除此之外，我们还希望将项目变更所影响的范围被限制得越小越好，因此 
需要应用单一职责原则（SRP）和共同闭包原则（CCP）来将经常同时被变更的类 
聚合在一起。
组件结构图中的一个重要目标是指导如何隔离频繁的变更。我们不希望那些频 
繁变更的组件影响到其他本来应该很稳定的组件，例如，我们通常不会希望无关紧 
要的GUI变更影响到业务逻辑组件；我们也不希望对报表的增删操作影响到其咼阶 
策略。岀于这样的考虑，软件架构师们才有必要设计并且铸造出一套组件依赖关系 
图来，以便将稳定的高价值组件与常变的组件隔离开，从血起到保护作用。
E1K
II
II另外，随着应用程序的增长，创建可重用组件的需要也会逐渐重要起来 
CRP又会开始影响组件的组成。最后当循环依卿川"见时，随着无循环依赖原则;即 
的应用，组件依赖关系会产生相应的I M 丿 和 ' A®
如果我们在设计具体类之前就来设计组件依赖关系，那么几乎是必然要失惋 
因为在当下，我们对项目中的共同闭包一无所知，也不可能知道哪些组件可以复； 
这样几乎一定会创造出循环依赖的组件。因此，组件依赖关系是必须要随着项卜 
逻辑设计一起扩张和演进的。 ■'
稳定依赖原则
依赖关系必须要指向更稳定的方向。
设计这件事不可能是完全静止的，如果我们要让一个设计是可维护的，那么空 
中某些部分就必须是可变的。通过遵守共同闭包原则（CCP）, 我们可以创造出 
某些变更敏感，对其他变更不敏感的组件。这其中的一些组件在设计上就已经是壬 
虑了易变性，预期它们会经常发生变更的。
任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依輙 
否则这个多变的组件也将会变得非常难以被修改。
这就是软件开发的困难之处，我们精心设计的一个容易被修改的组件很可能主
由于别人的一条简单依赖而变得非常难以被修改。即使该模块中没有一行代码需雯 
被修改，但是整个模块在被修改时所面临的挑战性也已经存在了。而通过遵守皈 
依赖原则（SDP）, 我们就可以确保自己设计中那些容易变更的模块不会被那取 
于修改的组件所依赖。
稳定性
我们该如何定义“稳定性”呢？譬 如 说 将 •个破币、y起來放，你认为它会处: 一个稳定的位置吗？当然不会。然而，除非受到外界因素干扰，否则硬币本身? 
在这个位置保持相当长的一段时间。因此稳定性应该与变更的频繁度没有直按关糸
HI
106第 44章组件耦合
但问题是硬币并没有倒，为什么我们却并不认为它是稳定的呢?
下面来看看Webster在线字典中的描述：稳定指的是“很难移动”。所以稳定 性应该与变更所需的工作量有关。例如，硬币是不稳定的，因为只需要很小的动作
就可以推倒它，而桌子则是非常稳定的, 因为将它掀翻需要很大的动作。
但如果将这套理论关联到软件开发的问题上呢？软件组件的变更困难度与很多 
因素有关，例如代码的体量大小、复杂度、清晰度等。我们在这里会忽略这些因素，
只集中讨论一个特别的因素 -让软件组件难于修改的一个最直接的办法就是让很
多其他组件依赖于它。带有许多入向依赖关系的组件是非常稳定的，因为它的任何
变更都需要应用到所有依赖它的组件上。
在 图 14.5中，X 是一个稳定的组件。因为有三个组件依赖着X ,所以X 有三个 
不应该被修改的原因。这里就说X 要对三个组件负责。另一方面，X 不依赖于任何 
组件，所以不会有任何原因导致它需要被变更，我们称它为“独立”组件。
图 14.5： X , 稳定的组件
下面再来看看图14.6中的Y 组件，这是一个非常不稳定的组件。由于没有其他 
的组件依赖Y ,所 以 Y 并不对任何组件负责。但因为丫同时依赖于三个组件，所以 
它的变更就可能由三个不同的源产生。这里就说丫是有依赖性的组件。架构整洁之道
€
F
E 14.6： Y, 一个非常不稳定的组件
稳定性指标
那么，究竟该如何来量化一个组件的稳定性呢？其中一种方法是计算所有入湘 
出的依赖关系。通过这种方法，我们就可以计算出一个组件的位置稳定性(positional 
stability) °
• Fan-in：入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量 • Fan-out：出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。 • I：不稳定性, I = Fan-out / (Fan-in + Fan-out).该指标的范围是[0,1], 1=0 意味着组件是最稳定的，匸\意味着组件是最不稳定的。
在这里，Fan-in和 Fan-out这两个指标】是通过统计和组件内部类有依赖的组斤 外部类的数量来计算的，具体如图14.7所示。
图 14.7：我们的例子
1 在之前的文章中，我曾经用过efferent, ajferent (简称Ce和 6 ) 这两个术语来指代Fan-out和 血 " 那只是我的一个个人偏好：我喜欢用人的中枢神经系统来比喻软件架构。
108第14章组件辎合
部釣类’因^Fan-out= \, /=l/4o
在C+十中’这些依赖关系一般是通过冊皿“恥语句来表达的。事实上，当每 
个源文件只包含一个类的时候，/指标是最容易计算的。同样在
Java中，/指标也可 
以通过Im port语句和全引用名字的数量来计算。
当/指标等于1时，说明没有组件依赖当前组件(FangO), 同时该组件却依 赖于其他组件(Fan-out>S。这是组件最不稳定的一种情况，我们认为这种组件是 
"不 负 责 的 (irresponsible) > 对外依赖的(dependent) n 。由于这个组件没有被其 
他组件依赖，所以自然也就没有力量会干预它的变更，同时也因为该组件依赖于其 
他组件，所以就必然会经常需要变更。
相反，当 1=0的时候，说明当前组件是其他组件所依赖的目标(Fan・in>°)， 同时其自身并不依赖任何其他组件(Fawt=0) o 我们通常认为这样的组件是“负 责 的 Sesponsibile)、不对外依赖的(independent) ”。这是组件最具稳定性的一 种情况，其他组件对它的依赖关系会导致这个组件很难被变更，同时由于它没有对 
外依赖关系，所以不会有来自外部的变更理由。
稳定依赖原则(SD P)的要求是让每个组件的/指标都必须大于其所依赖组件 
的 / 指标。也就是说，组件结构依赖图中各组件的/指标必须要按其依赖关系方向 
递减。
并不是所有组件都应该是稳定的
如果一个系统中的所有组件都处于］ 
, 这显然不是我们想要的。 -
最高稳定性状态，那么系统就一定无法再进 
一方由7 、&曰狱/ 口我们仔主中。事实上，我们设计组件架构图的目的就是要决
；应 该 让 哪 些 蠡 稳 :让 矗 组 件 不 稳 定 。譬如在图祗中，我们所示范的就是 
一个具有三个组件的系统的理想配置。
109架构整洁之道
箭头向上的依赖关系，而这些关系是违反SDP （以及后面将会讨论的人口戸丿彳 
丿的。
1 stable
I instable^ I I_! instable TT
r=i
1=1
J=0
® 14.8： 一个具有三个组件的系统的理想配置
下面再通过图14.9来看看违反SDP的情况:
Stable
!一_J  instable 1
1 _ 1
1
1
1
1
L| instable 1
1
1
1=1 1 J=1_J
百 1
Flexible
图 14.9：违反SDP的情况
在图14.9中，F le x ib le 是在设计中要确保其易于变更的组件，因此我们会翟 
F le x ib le 是不稳定的。然而，S ta b le 组件的开发人员却引入了对Flexible > 
的依赖。这种情况就违反了 SD P,因为S ta b le 组件的/指标要远小于FlexibE /指标。这将导致F le x ib le 组件的变更难度大大增加，因为对F lex ib le组恥 何修改都必须要考虑S tab le组件及该组件自身存在的依赖关系。 如果想要修复这个问题，就必须要将s ta b le 与 F le x ib le 这两个组件之； 依赖关系打破。为此，我们就盂耍了解这个依赖关系到底为什么会存在，这里］ 
是因为S ta b le 组件中的某个类u 需要使用F le x ib le 组件中的一个类。
110第 44章组件耦合
14.10所示:
图 14.10： Stable组件中的U 使用了 Flexible组件中的C
我们可以利用DIP来修复这个问题。具体来说就是创造一个U Server组件, 并在其中设置一个US接口类。然后, 确保这个接口类中包含了所有U 需要使用的
函数，再让C 实现这个接口，如图14.11所示。这样一来，我们就将从S ta b le 至U F le x ib le 的这条依赖关系打破了，强迫这两个组件都依赖于U Servero现在,
U S e rv er组件会是非常稳定的（7=0） , 而 F le x ib ile 组件则会依然保持不稳定 
的状态（7=1） , 结构图中所有的依赖关系都流向/递减的方向了。
图 14.11：让 C实现接口类US
抽象组件
读者可能会觉得创造新组件（譬如上述例子中的U Service组件，它其实只包 含了一个接口类）这种做法挺奇怪的。因为这样的组件中几乎不包含任何可执行的 
代码！但事实上，这种做法在C#或者Java这种静态类型语言中是非常普遍的，而 且也必须这样做。因为这些抽象组件通常会非常稳定，口J以被那些相对不稳定的组 
件依赖。
而当我们使用Ruby和 Python这种动态类型语言时，这些抽象接口事实上并不 存在，因此也就没有对它们的依赖。动态类电语言中的依赖关系是非常简单的’因 
为其依赖反转的过程并不需要声明和继承接口。
111架构整洁之道
稳定抽象原则
-个组件的抽象化程度应该与其稳定性保持一忍
高阶策略应该放在哪里
在- 个软件系统中，总有些部分是不应该经常发生变更的。这些部分通常用于 
衷现该系统的高阶架构设计及一些策略相关的高阶决策。我们不想让这些业务快策 
和架构设计经常发主变更，因此这些代表了系统咼阶策略的组件应该被放到稳定繳
件 (7=0)中，而不稳定的组件(匸1)
的部分。
然而，如果我们将高阶策略放入稳定组件中，那么用于描述那些策略的源代码 
就很难被修改了。这可能会导致整个系统的架构设计难于被修改。如何才能让-个 
无限稳定的组件(7=0)接受变更呢？开闭原则(OCP)为我们提供了答案。这个原 
则告诉我们：创造一个足够灵活、能够被扩展，而且不需要修改的类是可能的，而 
这正是我们所需要的。哪一种类符合这个原则呢？答案是抽象类。
稳定抽象原则简介
Ln  i口 就咻卜组件层次上的D IPo因为SDP漿 晌;抽;篇/告诉我们稳定性本身就隐含用
112第 14章组件耦合
然而,D IP毕竟是与类这个层次有关的原则—— 对类来说，设计是没有灰色地 
带的。 •个类要么是抽象类,要么就不是。SDP与SAP这对原则是应用在组件层面 
上的，我们要允许一个组件部分抽彖，部分稳定。
衡量抽象化程度
卜面，假设A 指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与 
接口所占的比例。那么：
• Nc：组件中类的数量。 • Na：组件中抽象类和接口的数量。 • 力：抽象程度，A=Na一Nc。
A 指标的取值范围是从0 到 1 ,值为0代表组件中没有任何抽象类，值为1就意 
味着组件中只有抽象类。
主序列
现在，我们可以来OR 定义组件的稳定性/与其抽象化程度/之间的关系了，具体
如图14.12所示。在该图中，纵轴为/值，横轴为/值。如果我们将两个“设计良 
好”的组件绘制在该图上，那么最稳定的、包含了无限抽象类的组件应该位于左上 
角(0,1),最不稳定的、最具体的组件应该位于右下角(1,0)。
图 14.12： I/A 图架构整洁之道
当然，不可能所有的组件都能处于这两个位置［ 因为组件通常都有各2, 
定程度和抽象化程度。例如一个抽彖类有时会衍丫「対•个抽象类，滋种僧勿" 
常见的.而这个衍‘I 讨 卅 「：训松臬种依赖广系的产1 内此'虽岁力纽々.,7
象的，但它并不是完全稳定的，上述依赖关系降低r 它的稳定程度。 卑 既然不能强制要求所有的组件都处于(0,1)和(i,o)这两个位置上，那么啟羽 设a 'i 图上存在着一个合理组件的区间。而这个区间应该可以通过排除法推导;' 也就是说，我们可以先找出那些组件不应该处于的位置(请参考图14.13) ：
(0,0) I (1,0)
图14.13：排除区
痛苦区
在 图 14.13中，假设某个组件处于(0,0)位置，那么它应该是一个非常稳定但也 
非常具体的组件。这样的组件在设计上是不佳的，因为它很难被修改，这意味着讥 
组件不能被扩展。这样一来，因为这个组件不是抽象的，而且它又由于稳定性的果 
因变得特别难以被修改，我们并不希望一个设计良好的组件贴近这个区域，因此㈣ 
周围的这个区域被我们称为痛苦区(zone of pain)。
当然，有些软件组件确实会处于这个区域中，这方面的一个典型案例就是址常
库的表结构(schema)。它在可变性上可谓臭名昭著，但是它同时又非常具体，话 被非常多的组件依赖。这就是面向对象应用程序与数据库z 间的接口这么难以管蹩 以及每次更新数据库的过程都那么痛苦的原因。第44章组件耦合
且件是丁•具型类库。虽然这种类库的/指标 
S trin g 组件，虽然其中所有的类都是具体
另一个会处于这个区域的典型软件纟刖斗 
为 1 ,但事实上通常是不可变的。例如 
的’豐 薛 :豐 得 太 过 普 遍 ，任何修改都会造成人范围的混乱，因此■ 
组件只能是不可变的。
不可变组件落在(0,0)这一区域中是无害的，因为它们不太可能会发生变更。正 
因为如此，只有多变的软件组件落在痛苦区中才会造成麻烦，而且组件的多变性越 
强，造成的麻烦就会越大。其实，我们应该将多变性作为图14.13的第三个轴，这 
时图14.13所展示的便是多变性=1时的情况，也就是最痛苦的切面。
无用区
现在我们来看看靠近(1,1)这一位置点的组件。该位置上的组件不会是我们想要 
的，因为这些组件通常是无限抽象的，但是没有被其他组件依赖，这样的组件往往 
无法使用。因此我们将这个区域称为无用区。
对于这个区域中的软件组件来说，其源码或者类中的设计问题通常是由于历史 
原因造成的。例如我们常常会在系统的某个角落里看到某个没有人实现的抽象类， 
它们一直静静地躺在那里，没有人使用。
同样的，落在无用区中的组件也一定会包含大量的无用代码。很明显’这类组
件也不是我们想要的。
避开这两个区域
序 列 线 (main sequence) 。
坐 落 于 主 序 列 线 上 的 组 件 不 会 ?;驚 稳 囂 囂 黑 驚 爲 盟 被 修 讐 
竄 蠶 翥 專 需 盂 二 蹄 会 心 吶 心 '
坐落于主序列线上的架构整洁之道
、
这使得它们会具有一定程度的抽象，同时它们也依赖了足够多的其他组件，、, 
得它一定会包含很务具体实现O 人*
在解条主序列线匕,组件所能处r•最优的位置是线的两端。 •个优秀的欤他 构||巾八心争取将门己设计的犬部分组竹以对能川川|胡必曲个位乩然而，如. 
. 险来说，大型■中的组件不町能做到完全抽象I 也不可能做麴I全稳J 
以我们只要追求让这些组件位于主序列线上，或者贴近这条线即町。 °
离主序列线的距离
接卜来介绍最后一个指标：如果让组件位于或者靠近主序列是可取的目标，. 
么我们就可以创建一个指标来衡量一个组件距离最佳位置的距离。
• D 指标】：距离D =|/+/-l|,该指标的取值范围是［0」］。值为°意味着组傀 
直接位于主序列线上的，值为1则意味着组件在距离主序列最远的位賢
通过计算每个组件的D指标,就可以量化一个系统设计与主序列的契合程度. 
另外，我们也可以用D 指标大于0 多少来指导组件的重构与重新设计。
除此之外，通过计算设计中所有组件的D 指标的平均值和方差，我们还可’ 
统计学的方法来量化分析一个系统设计。对于一个良好的系统设计来说，D指吧 
平均值和方差都应该接近于0o其中，方差还可以被当作组件的“达标红线”芒 
用，我们可以通过它找出系统设计中那些不合常规的组件。
在 图 14.14中，我们可以看到大部分的组件都位于主序列附近，但是有些片 
处于平均值的标准差（Z=l）以外。这些组件值得被重点分析，它们要么过于眦 
依赖不足，要么过于具体而被依赖得太多。
1 在我之前的文章中，曾经将这个指标叫作°, 但是在这本书里显然没有理由这样做
116第 4 4 章组件耦合
1
图 14.14：组件分散图
D 指标的另外一种用法是按时间来跟踪每个组件的值，下面用图14.15来做一 
个示范。在该图中可以看到，P ay ro ll组件在最近几次发布中累积了一些意外的对 外依赖。图中的Q=0・l是组件的达标红线，R2.1这个值已经超出了红线范围，这就 告诉我们现在值得花一些精力来找出这个组件偏离主序列线的原因了。
0.2 - 1
软件包：工资计算程序
D 0.1
R L0 R1.1 R1.2 R2.0 R2.1
发布版本
图 14.15：针对单组件的Q 值时间趋势图
本章小结
本章介绍了各种可用于依赖关系管理的指标，它勺J町以被用来里化分析某个系 
统设计与“优秀”设计模式之间的契合度。根据以往的经验，组件之间有些依赖关 
系 ;鳥 霊 依 赖 关 系 则 是 不 好 的 ,这 些 经 验 最 :驚 豎 囂 个 驚 穿 定 
当然，指标并不等同于真理，它只是对我们所定义标准的一个衡量。这些扌期冃定 
是不完美的，但是我希望它们对读者有价值。