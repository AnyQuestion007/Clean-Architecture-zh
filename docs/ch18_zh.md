第 18章 边 界 剖 析
这也节为什么面向乂寸象编程近几十年来逐渐成为-种重要编程范式的原因之一。如 
果不采用面向对象编程模式或是类似的多态实现，架构师们就只能退回到用函数指 
针这种危险的模式来进行组件解耦的时代。由于大部分架构师认为大量采用函数指 
针过于危险，所以在那样的情况卜，他们通常都在权衡利弊之后就干脆放弃划分组 
件了。
最简单的跨边界调用形式，是由低层客户端来调用高层服务函数，这种依赖关 
系在运行时和编译时会保持指向一致，都是从低层组件指向高层组件。
在 图 中 ，我们可以看到控制流跨越边界的方向是从左向右的，Client调 
用了 Service ± 的函数f(),并向它传递了一个Data实例。这里的CDS〉标记是 
指 Data是一个数据结构。Data实例的具体传递方法可以是函数的调用参数，也可 以是其他更复杂的传递方式。读者在这里需要注意的是，Data的定义位于边界的被 
调用方一侧。
Client > Service
----------- S>q
> Data
图1&1：从低层组件跨越边界到达高层组件的控制流
+ f
但当高层组件中的客户端需要调用低层组件中的服务时，我们就需要运用动态 
形式的多态来反转依赖关系了。在这种情况下，系统在运行时的依赖关系与编译时 
的依赖关系就是相反的。
在图18.2中，控制流跨越边界的方向与之前是一样的，都是从左至右的。这里 
是高层组件Client通过Service接口调用了低层组件Servicelmpl上的函数 
f()。但请读者注意，图 18.2中所有的依赖关系却都是从右向左跨越边界的，方向 是由低层组件指向高层组件的。同时，我们也应该注意到，这一次数据结构的定义 
是位于调用方这一侧的。
157架构整洁之道
图 18.2：反方向跨越边界的控制流
即使是在一个单体部署、静态链接的可执行文件中，这种自律式的组件如 
然可以极大地帮助整个项目的开发、测试与部署，使不同的团队可以独立开发; 
的组件，不会互相干扰。高层组件与低层细节之间也可以得到良好的隔离，独立; 
进。 
'
在单体结构中，组件之间的交互一般情况下都只是普通的函数调用，迅速帀赛 
价，这就意味着这种跨源码层次解耦边界的通信会很频繁。
由于单体结构的部署需要编译所有源码，并且进行静态链接，这就意味着渥 
系统中的组件一般都会以源码形式交付。
部署层次的组件
下面我们来看看系统架构最常见的物理边界形式：动态链接库。这种?!■形式包
括.Net的 DLL、Java的jar文件、Ruby Gem以及UNIX的共享库等。这种类型卿 
件在部署时不需要重新编译，因为它们都是以二进制形式或其他等价的可部署形* 
2 付的。这里采用的就是部署层次上的解耦模式。部署这种类型的项目，就是繰 
所有可部署的单元打1 成一个便于操作的文件格式，例 如 WAR文件，甚至 郝 
是一个目录（或者文件夹）。
除这一山以外，这种按部署层次解耦的组件与单体结构几乎是一样的，其用: 
的函数仍然处十同一个进程、同一个地址空间中。管理组件划分依赖关系的沁第18章边界剖析
基本上是和上文一致的1°
与单体结构类似，按部署层次解耦的组件之间的跨也界调用也只是普通的函数 
调用，成本很低。虽然动态链接或运行时加载的过程本身可能会有-个一次性的调 
用成本，但它们之间的跨边界通信调用依然会很频繁。
线程
单体结构和按部署层次划分的组件都可以采用线程模型。当然，线程既不属于 
架构边界，也不属于部署单元，它们仅仅是一种管理并调度程序执行的方式。一个 
线程既可以被包含在单一组件中，也可以横跨多个组件。
本地进程
系统架构还有一个更明显的物理边界形式，那就是本地进程。本地进程一般是 
由命令行启动或其他等价的系统调用产生的。本地进程往往运行于单个处理器或多 
核系统的同一组处理器上，但它们拥有各自不同的地址空间。一般来说，现有的内 
存保护机制会使这些进程无法共享其内存，但它们通常可以用某种独立的内存区域 
来实现共享。
最常见的情况是，这些本地进程会用socket来实现彼此的通信。当然，它们也 可以通过一些操作系统提供的方式来通信，例如共享邮件或消息队列。
每个本地进程都既可以是一个静态链接的单体结构，也可以是一个由动态链接 
组件组成的程序。在前一种情况下，若干个单体过程会被链接到同一个组件中。而 
在后一种情况下，这些单体过程可以共享同一个动态链接的可部署组件。
1 当然，静态形式的多态通常就不适用于这种情况了。
-
159架构整洁之道
小卄戊某种超级组件’该进程叶啄列较低层次的细 
卩可以将卜地进和仃 皿';们匕间的依赖
L体结构』二述制组件基本相同曲其源码 
致的，始终指向更高层次的组件I
I 着高层进程的源码中不应该包含低层进程的名字、 
囂;务必要记住，该系统架构的设计目标是让低
件组：J ；；爲 恥 山 Z E 
另外.本地进卅z 间w隔离策也与单 中的依赖尖系跨越架构边界的方向是
对本地进程来说，这就意 
物理内存地址或是注册表键名。 
层进程成为高层进程的一个插件。
本地进程之间的跨边界通信需要用到系统调用、驚 ? 囂 驚 驚 嚣 竽 
间的上下文切换,成本相对来说会更高一些,所以运里而要谨慎地控制通缶的次数。
服务
系统架构中最强的边界形式就是服务。一个服务就是一个进程，它们通常由命 
令行环境或其他等价的系统调用来产生。服务并不依赖于具体的运行位置，两个互 
相通信的服务既可以处于单一物理处理器或多核系统的同一组处理器上，也可以彼 
此位于不同的处理器上。服务会始终假设它们之间的通信将全部通过网络进行。
服务之间的跨边界通信相对于函数调用来说，速度是非常缓慢的，其往返时间
可以从几十毫秒到几秒不等。因此我们在划分架构边界时，一定要尽可能地控制通 
信次数。在这个层次上通信必须能够适应高延时情况。
■・・
除此之外，我们可以在服务层次上使用与本地进程相同的规则。也就是让较低 
层次服务成为较高层次服务的“插件” 0 为此，我们要确保高层服务的源码中没有 
包含任何与低层服务相关的物理信息（例如URI） °
160第 18章 边 界 剖 析
本章小结
除单体结构以外, 大部分系统都会同时采用多种边界划分策略。一个按照服务
层次划分边界的系统也可能会在某一部分采用本地进程的边界划分模式。事实上, 
服务经常不过就是一系列互相作用的本地进程的某种外在形式。无论是服务还是本 
地进程，它们几乎肯定都是由一个或多个源码组件组成的单体结构，或者一组动态 
链接的可部署组件。
这也意味着一个系统中通常会同时包含高通信量、低延迟的本地架构边界和低
通信量、高延迟的服务边界。