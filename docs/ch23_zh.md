第 23章
展示器和谦卑对象架构整洁之道
在第22章中，我们引入了展示器(presenter)的概念，展示器实际上是采 卑对象｛humble object模式的博种形式，这种役讣模式町以很好地帮助识别和 系统架构的.边界。事实上，第22章所介绍的榕沾架构川就充满了大量谦卑对象的揃 
现体。
谦卑对象模式
谦卑对象模式】最初的设计目的是帮助单元测试的编写者区分容易测试的行为 
与难以测试的行为，并将它们隔离。其设计思路非常简单，就是将这两类行为拆分 
成两组模块或类。其中一组模块被称为谦卑(Humble)组，包含了系统中所有难以 测试的行为，而这些行为已经被简化到不能再简化了。另一组模块则包含了所有不 
属于谦卑对象的行为。
例如，GUI通常是很难进行单元测试的，因为让计算机自行检视屏幕内容，并 
检查指定元素是否出现是非常难的事情。然而，GUI中的大部分行为实际上是很一 
易被测试的。这时候，我们就可以利用谦卑对象模式将GUI的这两种行为拆分成展 
示器与视图两部分。 '
展示器与视图
然后 
如果应用程
视图部分属于难以测试的谦卑对象。这种对象的代码通常应该越简单啟 
只应负责将数据填充到GUI上，而不应该对数据进行任何处理。 越’
展示器则是可测试的对象。展示器的工作是负责从应用程序中歸数 
按视图的需要将这些数据格式化，以便视图将其呈现在屏幕上。例女 取偽’ 
序需要在屏幕上展示一个日期，那么它传递给展示器的应该是一个u, Q 狀 
后展示器会将该对象格式化成所需的字符串形」匕 并 将 匕 顷 充 到 ;當 离 ］象°心
1 请参考 Gerard M eszaros 所著的 x Un it Test Patterns: Refactoring Test Code 一书第 695 叶 出版社，2007 年出版）。 Addison-Wesley
186第 23章 展示器和谦卑对象
• • 1
*
一如果应用程序需要在屏幕］二展示金额,那么它应该将c u m c y 对象传递给展 示器。展不器随后会将这个对象按所需的小数位数进行格式化，并加上对应的货币 
标识符，形成」个字符串存放在视图模型中。如果需要将负数金额显示成红色,那 
么该视图模型中就应该有一个简单的布尔值被恰当地设置°
另外，应用程序在屏幕上的每个按£ (|首；应该有其对应欝J名称, 这些名称也是由 
展示器在视图模型中设置的。如果某个按钮需要变灰，展小器就应该将相向的开关 
逻量戈置成对应的布尔值。同样，菜单中每个菜单项所显小-的值，也应该是一个个 
由展示器加载到视图模型中的字符串。应用程序在屏幕上显示的每个单选项、乡临 
项以及文本框的名字也都如此，在视图模型中都有相应的字符串和布尔值可供展示 
器做对应的设置。即使屏幕上要加载的是一个数值表，展示器也应该负责把这些数 
值格式化成具有表格属性的字符串，以供视图使用。
总而言之，应用程序所能控制的、要在屏幕上显示的一切东西，都应该在视图 
模型中以字符串、布尔值或枚举值的形式存在。然后，视图部分除了加载视图模型 
所需要的值，不应该再做任何其他事情。因此，我们才能说视图是谦卑对象。1
测试与架构
介所周知，强大的可测试性是一个架构的设计是否优秀的显著衡量标准之一。 
谦卑对象模式就是这方面的一个非常好的例子。我们将系统行为分割成可测试和E 
可测试两部分的过程常常就也定义了系统的架构边界。展示器与视图之间的边界只 
是多种架构边界中的一种，另外还有许多其他边界。
1 “谦卑”在这里是拟人化的,
译者注
识到自己的局限性，只发挥自己的桥梁和通
信作用，并不从中干预信息的传输。架构整洁之道
数据库网关
对 于 用 例 交 互 interactor）与数据库中间的组件，我们通常称之为数据库网尹 这些数据库网关本身是一个多态接口，包含了应用程序在数据库上所要执行的创建 
读取、更新、删除等所有操作。例如，如果应用程序需要知道所有昨天登录系统的舟 
尸的姓，那 么 U serG atew ay接 口 就 应 该 包 含 一 个 getLastNamesOfu 
WhoLoggedlnAfter方法，接收一个D ate参数，并返回一个包含姓的列表。
另外，我们之前说过，SQL不应该岀现在用例层的代码中，所以这部分的功能 
就需要通过网关接口来提供，而这些接口的实现则要由数据库层的类来负责。显然: 
这些实现也应该都属于谦卑对象，它们应该只利用SQL或其他数据库提供的接口来 
昉问所需要的数据。与之相反，交互器则不属于谦卑对象，因为它们封装的是特定 
应用场景下的业务逻辑。不过，交互器尽管不属于谦卑对象，却是可测试的，因为 
数据库网关通常可以被替换成对应的测试桩和测试替身类。
数据映射器
架 应 囂 專 囂 囂 囂 的 囂 ;现 在 我 们 来 思 考 一 下 — 这类的阴框 
的。監 很 霊 常 是 專 结 常 箕 囂 為 囂 ］事实上是压根就不存在 
户角度来说，对象疋一些操作的集合，而不是简单的数据结构体。
与之相反，数据结构体则是-组公开的数据变量其中不句含件何行为信自 
所以ORM更应该被称为“数据映射器”，因 为 它 為 囂 篇 農 篦 驚 加
I 请参考 Martin Fowler 等人所著的 Patterns of Enternri^ a 亠 出版社，2003 年出版）第 466 页。 ^PPhcanon Architecture 一 书 （Addis。. Wesley
188载到了对应的数据结构中。
浜
蠶牆和囂鶯霭鹦當二囂卑沁层。
服务监听器
如果我们的应用程序需要与其他服务进行某种交互，或者该应用本身要提供某 
一套服务，我们在相关服务的边界处也会看到谦卑对象模式吗？
答案是肯定的。我们的应用程序会将数据加载到简单的数据结构中，并将这些 
数据结构跨边界传输给那些能够将其格式化并传递其他外部服务的模块。在输入端, 
服务监听器会负责从服务接口中接收数据，并将其格式化成该应用程序易用的格式。 
总而言之，上述数据结构可以进行跨服务边界的传输。
本草小结
在每个系统架构的边界处，都有可能发现谦卑对象模式的存在。因为跨边界的 
通信肯定需要用到某种简单的数据结构，而边界会自然而然地将系统分割成难以测 
试的部分与容易测试的部分，所以通过在系统的边界处运用谦卑对象模式，我们可
以大幅地提高整个系统的可测试性。第24章第 24章不完全边界
构建完整的架构边界是•件很耗费成本的申. 
■ I 俨 &界 接 口 ，用于输入和输出的数据结构・ 
以便将系统分割成IJ独立编译与部署的组件识屮厶 
量的后期维护工作。 • ° 皿
存•这个过程中,需要为系统设计 
一以及所有相关的依赖关系管理, 
孑涉及大量的前期匚作,以及大
- 在 况 卜 」 位优秀的架构师都会认为设计架构边界的成本太高了一但 
为了应对将来可能的需要，通常还是希望预留•个边界
但这种预防性设计在敏捷社区里是饱受诟病的，因为它显然违背了 YAGNI原则
"You Areift Going to Need It” , 意即“不要预测未来的需要”）。然而，架构师 
的工作本身就是要做这样的预见性设计，这时候,我们就需要引入不完全边界partial 
boundary）的概念了。
省掉最后一步
构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部 
署的组件之后，再把它们构建成一个组件。换句话说，在将系统中所有的接口、用 
于输入/输出的数据格式等每一件事都设置好之后，仍选择将它们统一编译和部署为 
一个组件。
显然，这种不完全边界所需要的代码量以及设计的工作量，和设计完整边界时 
是完全］样的。但它省去了多组件管理这部分的工作，这就等于省去了版本号管理 
和发布管理方面的工作一这其中的工作量其实可不小。
这也是FitNesse项目早期所采取的策略。我们在设计W e b 服务器之初就将它设 计为-个可以独立于wiki和测试部分的组件。该设计背后的想法是划床来可能需 总 用 囂 e X l 构 建 其 他 应 用 釁 鬻 囂 总 常 ; 鳥 葺 组 我们希望用户只需下载一个问文和立即可以执仃:小需u w去寻找其他的2 文 件，更不需要操心版本兼容性等间题。架构整洁之道
Wiki幺际;
在这里，FitNcssc项 II的故事也可以作为一个反例来说明这种设计的危 随着时间的扌仆移，我们慢何发现，将 Web细件独也的需求越来越少，Wik：f " 
Web m件的隔肉也弱化了。到如今，如果真想要再分离Web组件的话，厶;川件 
工作量。 
，才 要 私
单向边界
在设计一套完整的系统架构边界时，往往需要用反向接口来维护边界两侧年決 
的隔离性。而且，维护这种双向的隔离性，通常不会是一次性的丁作P 雲亜甘: 
持续地长期投入资源维护下去。 J 匕 心 知
单 曲 為 爲 皈 g 駕 囂 焙 
使用的是一个由S e rv ic e lm p l类 实 现 的 S e rv ic e B o u n d a ry 接 口 。
很明显，
将 C lie n t 
清楚地看到， 
有采用双向反向接口, 
隔离了。
实基础。为了未来 
。同时，我们也能 
隔离问题。由于没 
t性来保证组件持久
192