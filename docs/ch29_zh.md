第29章
整洁的嵌入式架构第 29章 整洁的嵌入式架构
::牒g 驚蔦:鴛囂蔦驚爲文霊嘗中聶
于较件本身并不会随时间推移而磨损，但硬件及其固件却会随时间 
推移而过时，随即也需要对软件做相应改动。”
这句话对我有如醍醐灌顶。D。遽在这里用到了两个专业名词，
我一直认为是显 
而易尢的;但疋其他人可能并没有这么觉得。其中，软件(software)应该是一种使 用周期很长的东西，而固件｛firmware｝则会随着硬件演进而淘汰过时。曾经开发过 嵌入式系统的人一定都知道，硬件系统是在持续不断地演进的。与此同时，随着新 
功能不断地增加，软件复杂度也在不断上升。
□Q
在这里，我想对Dough ± 面的那个观点做一点补充: “虽然软件质量本身并不会随时间推移而损耗，但是未妥善管理的硬件 
依赖和固件依赖却是软件的头号杀手。”
也就是说，本可以长期使用的嵌入式软件可能会由于其中隐含的硬件依赖关系 
而无法继续使用，这种情况是很常见的。
我个人很喜欢Doug对固件所做的定义，但我们也可以来看一下其他人对固件 的定义，以下是我目前所找到的一些说法：
• “固件通常被存储在非可变内存设备，例如ROM、EPROM或者闪存中。”
( https://en.wikipedia.org/wiki/Firmware)
• “固件是直接编程在一个硬件设备上的一组指令或者一段程序。”
( https://techterms.com/definition/firmware)
• “固件是嵌入在 _个 硬件中的软件程序。”
(https://www」ifewire.com/what・is4irmwa&2625881)
i n
参见 https://insights.sei.cmu.edu/s4唧 2011/08/the・gwwing・impormce•of-sustaining-sotitware-fbr-thedod.架构整洁之道
•■ 固 件是被写入到只读内存设备中的（R E 誓 或 数 ■
（iMtp://wwwAvcbopcdiaxonVTERM/F/fnmwarc.html） 艮的这段观点表述业钱意识到'大家普遍警鬻 固 黑 需 农 呵 
至卜是过时的「同件并仆-定是指存储在R O M 中 驚 囂 ；炳 M 鷲 誉 
储的位&定义的*而是由其代码的依赖关系，及 其 豊 ' 主 和 难 度 上 
的变化來丘义的。硬件的浊'进是显而易见的（如果对此有彳口 口’叽'-想你手 
中的手机），我们在架构嵌入式代码时要时刻记住这一点°
我并不反对固件,
真的应该少写点固件,
也不反对固件工程师（我自己也曾经写过固件）。但是我们 
而多写点软件。事实上，我最失望的是固件工程师竟然要写
那么多固件程序!
还有，非嵌入式工程师竟然也要写固件程序！虽然你可能并不是嵌入式系统的 
开发者，但如果你在代码中嵌入了 SQL或者是代码中引入了对某个平台的依赖的话 
其实就是在写固件代码。譬如，Android X 程师在没有将业务逻辑与Android API 离之前，实际上也是在写固件代码。
我参与过很多软件项目，其中一些产品的功能代码（软件）与硬件支持代码（固
件）的边界模糊得几乎不存在。例如，在 20世纪90年代末，我有幸参与了一套通 
信系统的重新设计，将其从时分复用（T D M ）模式迁移到V O I P 模式。虽然VOIP
如今已经是行业标准，但是从20世纪50年代到60年代，T D M —直都是非常先进 
的技术，直到20世纪80年代和90年代它也被广泛部署在各种系统中。
每当我们向系统工程帅提出一个产品问题—— 系统在某个情况下应该如何处理 
某通电话，这位系统工程师就会消失一段时间，然后给出一个非常具体的答案。我 
们问他是从哪里查到这个结果的？答案是“从当前的产品代码里！”这些复杂交错 
的老代码己经成为系统定义的-部分。该系统在实现过程中并没有区分T D M 技 
术代侧和拨打电话这样的业务逻辑代码。整个产品从头到尾都与具体技术、具体硬 
件息息相关，无法分割。叮以说整个产品已经成为事实上的固件。、
••
自 然 ;鳥
T
消 鳥 爲 陽 囂 駕 是 牆 嚮 驕 爲 
以解析消息，然后将消息分发给具体的处理代码。蠶 囂 囂 瓷 醴 理 酚第29章 整洁的嵌入式架构
发器的代码和操作UART硬件啲代码往往会被放存同-个文件中消胃处理器的代 
" m u 细讥这样來木可以长时间使用的消息处 理器代码变成J 一段固件代码，这太不应诊」
了，但是借助Doug对软件和固件的定义, :1J硬件、固《卜区分开來也己经有一段时间 
我现在可以把这件事情说得更明白」些。
对于程丿予员和丄程U巾，我的意思很明确：不要再写固件代码了，让我们的代码 
活得更久点！当然，我们也不能总是空谈理念，下面就来看一下应该如何通过好 
的架构设计让嵌入式代码拥有更长的有效生命周期。
“程序适用测试乃测试
为什么这么多嵌入式软件最后都成了固件？看起来，很可能是因为我们在做嵌 
入式设计时只关注代码能否顺利运行，并不太关心其结构能否撑起一个较长的有效 
生命周期。Kent Beck描述了软件构建过程中的三个阶段（引号部分是他的原话，楷 
体部分是我的注解）:
1. “先让代码工作起来” 如果代码不能工作，就不能产生价值。
2. “然后再试图将它变好 -通过对代码进行重构，让我们自己和其他人更
好地理解代码，并能按照需求不断地修改代码。
3. “最后再试着让它运行得更快” 按照性能提升的“需求”来重构代码。
我所见过的大部分“野生”的嵌入式代码，都只关注先让匕工作起来这个 
目标一一也许还有些团队会同时痴迷于 
会加入各种微优化。在 《人月神话》 
"抛弃一个设计” o Kent和 Fred
“让它更快”这个目标，不放过任何—个机 
这本书中，Fred Brooks建议我们应该随时准备 说的其实是同一件事： “在实践中学习正确的工作
方法，然后再重写一个更好的版本”。
这是一种用来控制串行端口的硬件设备。
毕竟目前大部分非嵌入式应用也
225架构整洁之道
仅仅停留在“可用”这个目标上，很少考虑为了长久使用而进行正确的设计
对于程序员来说，让他的程序工作这件事只能被称为"程序适用测试(qpp u test} ” o 一个程序员，不论他写的是否是嵌入式程序，如果目标仅仅是让程;善"e 工作，恐怕对他的老板和这个程序本身而言都是一件坏事。毕竟，编程这件事;以 
不止是让程序可以工作这么简单。 "远
下面我们来示范一下可以通过“程序适用测试”的代码是什么样子的。先来看 
一个小型嵌入式系统中某个源文件中的一段函数声明：
ISR(TIMERl_vect) { ... } ISR(INT2_vect) { ... } void btn—Handler(void) { ••• } float calc_RPM(void) { • • • ) static char Read_RawData(void) { ••・} void Do_Average(void) { ••• } void Get_Next_Measurement(void) { ... } void Zero_Sensor_l (void) { ■… } void Zero_Sensor_2(void) { •.. } void Dev_Control(char Activation) { } char Load_FLASH_Setup(void) { •… } void Save_FLASH_Setup(void) { … . } void Store_DataSet (void) { •… } float bytes2float(char bytes[4 ] ) { } void Recall_DataSet(void) { ••• } void Sensor_init(void) { •… } void uC_Sleep(void) { ••• }
可以看到该源文件中的函数是按一定顺序列出来的。现在我们要按R召功能进行 
分组： 解 '、
用于定义域逻辑(domain logic)的函数
float calc_RPM(void) { } void Do_Average (void) { •… } void Get_Next_Measurement(void) { void Zero_Sensor_l(void) { ••. } void Zero_Sensor_2 (void) { •… }
226第29章 整洁的嵌入式架构
• 用于设置硬件平台的函数
ISR(TIMERl_vect) { ... }★ ISR(INT2_vect) { ... } void uC_Sleep(void) { .… } 
响应开关按钮动作的函数 
void btn_Handler(void) {. void Dev_Control(char ~ 
用于从硬件中获取a/D 输入读数的函数 
sta.tic chmi? Read_R3.wD3.t3. (void) { }
• 用于执行持久化存储的函数
}
Activation) { … . }
char Load_FLASH_Setup(void) { … } void Save_FLASH_Setup(void) { … } void Store_DataSet(void) { … }
float bytes2float (char bytes[4] ) { . . . } 
void Recall_DataSet(void) { •・• }
• 功能与其名字不符的函数
void Sensor init (void) { . . . }
在查看该应用程序其他源代码文件的过程中，我同样发现了许多理解上的障碍 
点。同时，我还发现这个项目的结构决定了该应用程序的所有代码只有在指定硬件 
平台上才能被测试。几乎代码的所有部分都知道它要运行在一个特殊的微处理器平 
台上，因为它们用的是“被扩展了的” C结构1 ,需要特殊的工具链和微处理器才能 
执行。除非这个产品永远不需要迁移到另一个硬件平台上，否则这段代码几乎不可 
能有长久的使用价值。
所以你看，这段代码的确能够正常工作：它的工程师也通过了“程序适用性测 
试”，但我们不能说该应用程序有一套整洁的嵌入式架构。
1 有些集成芯片会给c 语言增加一些特殊的关键字，以简化访问寄存器和/°端口的C代码。然而，这 样做的话，代码就不再符合c 语言的标准了。
227架构整洁之道
目标硬件瓶颈
嵌入式系统的程序员 
情—— 例如，有限的地址？ 
常规的用户接L1、感应器 
统的硬件是和它的软件、 
往往没有任何地方可以运 
们要等到真正拿到硬件时’-----
这会在多大程度上拖慢我们的开发进度?
是的，我们承认嵌入式系统的开发有其特殊性，甘欠入式匚无王师的工作有其特跌 
性，但我们并不认为嵌入式开发特殊到本书所讲的原则都不适用的程度。
标硬件瓶颈（target-hardware bottleneck^是嵌入式开发所特有的一个问题,
如果我们没有采用某种清晰的架构来设计嵌入式系统的代码结构，就经常会面临只 
能在目标系统平台上测试代码的难题。如果只能在特定的平台上测试代码，那么这 
一定会拖慢项目的开发进度。
整洁的嵌入式架构就是可测试的嵌入式架构
下面，我们来看一下具体应如何将架构设计的原则应用在嵌入式软件和固件上. 
以避免陷入目标硬件瓶颈。
分层
分丿，可以有很多种方式，这里先按图29.1所示的设计将系统分成三层。首先' 
底层疋硬件丿茁° 11:如 Doug警吿我们的那样,由于科技的进步与摩尔定律，硬件是第29章 整洁的嵌入式架构
图29」：三层结构设计
硬件与系统其他部分的分隔是既定的—— 至少在硬件设计完成之后如此（如图
29.2所示）。这也是在我们试图通过程序适用测试之时往往会发生问题的地方。因
为没有什么东西可以真正阻碍硬件实现细节污染到应用代码。如果我们在构建代码 
的时候不够小心，没有小心安排哪些模块之间可以互相依赖，代码很快就非常难以 
更改了。请注意，这里所说的变更不仅仅是指来自硬件的变更，还包括用户的功能
性变更、修复代码中的Bug。
229架构整洁之道
硬件是实现细节
医2 9 .\软件与固件之间的边界往往没有代码与硬件之间的边界那么清晰
所以，我们的工作之一就是将这个边界定义得更清晰一些。软件与固件之间労 
边界被称为硬件抽象层（HAL）, 如图29.4所示。这不是一个新概念，它在PC上 
的存在甚至可以追溯到Windows诞生之前。
图 29.4；硬件抽象层
H AL
H A L 的〃在是为了给它上层的软件提供服务，HAL的 API应该按照这些软件 
的需要來量身定做。例如’固件可以直接将字节和字节组存入闪存中。相比之卜， 
软件需帅丿畀〃、杲神持久化半台保存和读取name/value对信息，它不应该关心駅 信息到底是被存储到闪存中＜ 磁盘中、云端存储中，还是在内存中读取/存储这蚱 
息。总Z ，叽的作用是为软件部分提供一种服务，以便隐藏具体的实现细节弄
230竟专门针对闪存的实现代码是一种细 叽 亦 它应该与软件部分. 
古 瓷 詈 驚 瓷 个 例 不 「 个LED被 连 "「 个GPIO比特位上。固件可以 
■ I ■ & 豐 嗫 L 则会提供Y B B r n j 爲 按 ，这种硬件抽象 层的层次疋亠当低的。现在，假役事们想将抽象层次从 硬 孱 次提升到软件/产品的 
层次。这时候就要弄清楚这个LED到底代表的是什么。假设它代衣了电池电量不足, 
那么其固豊:或该电路板的支持包)可能就会负责提供Led_Tu"0n(5)函数，而 H A L 则负贝提供Indicate_L ow B attery ()函数。由此可见，H A L 层是按照应用 程序的需要来提供服务的。同时，我们也能看出来系统的每一个分层中都可以包含 
许多分层。相对于之前的固定分层法，这里更像是一种无限分层模式。总之，GPIO
位的对应关系应该是一个具体的实现细节，它应该与软件部分隔离。
不要向HAL的用户暴露硬件细节
依照整洁的嵌入式架构所建构的软件应该是可以脱离目标硬件平台来进行测试 
的。因为设计合理的H A L 可以为我们脱离硬件平台的测试提供相应的支撑。
处理器是实现细节
当我们的嵌入式应用依赖于某种特殊的工具链时，该工具链通常会为我们提供
一些“c i〉帮 助 "性 质 的 头 文 件 。这些编译器往往会自带一些基于C 语言的 扩展库，并添加一些用于访问特殊功能的关键词。这会导致这些程序的代码看起来 
仍然用的是C 语言，但实际上它们已经不是C 语言了。
m
有时候, 这些嵌入式应用的提供商所指定的°编译器还会提供类似于全局变量
的功能，以便我们直接访问寄存器、I/O端II、时钟侣息、i/cH立、中断控制器以及 其他处理器函数，这些函数会极大地方便我们对相关硬件的访问°但请注意，一旦 
你在代码中使用了这些函数，你写的就不再是c 语吕程序，它就不能用其他编译器 来编译了，甚至可能连同一个处理器的不同编译器也不行。
即便我们假设这些硬件提供商这
1 这里使用HTML代码是故意的。
231架构整洁之道
* --------------------------- ■ — f ■ — L -
样做真的是为了 
是问题的关键。
的使用范围。
下面来看-下针对ACME DSP （数字信号处理器）系 统 设 讣 的 头 文 仆 WileE
Coyote米用的就是这个系统:
#ifndef _ACME_STD_TYPES #define _ACME_STD_TYPES
#if defined(_ACME_X42) typedef unsigned int Uint _32; typedef unsigned short Uint _16; typedef unsigned char Uint _8; typedef int Int_32; typedef short Int_16; typedef char 8;
#elif defined(_ACME_A42) typedef unsigned long Uint _32; typedef unsigned
■
int Uint _16;
typedef unsigned char Uint_8; typedef long Int 32; typedef int Tnt 16; typedef char Int 8;
#else
ei 2tor 匕日cmetypgs . h> is not supported for this environment 
#endif
#endif
该 acm etypes.h 头文件通常不应该直接使用。因为如果这样做的话，代码就 和某个ACME DSP绑定在■起了。这时候你口J能会问，我们在这里写代码不就是为 
了使用ACME DSP吗？不引用这个头文件如何编译代码呢？但如果引用了这个头 
文件，就静川口」时立义了_ ACME_X42和_ ACME_A42,那么我们的代码在平台之
232第29章 整洁的嵌入式架构
外进行测试的时候整数类型的大小就4 g 代码迁移到另外-个处理器］•的时J 、：w , 范围，就会人大增加这顶辻林「作的爲 仙 涮 ACME头才件被引用的
杼 编 囂 驚 ;'们 应 该 用 更 标 准 的 ■ • h 来 替 昭 如 果 目 S E I I M H 4 我们可以自』 「 个。例 师 山 就 -个 针 
' 八 P 用 a c m e ty p e s.h 来构建目标的自定义s td in t.h ：
错误的。更糟糕的是,有一天当我们想将
# if n d e f _STDINT H # d e fin e STDINT H # in c lu d e < a c m e ty p e s .h > t y p e d e f U in t_ 3 2 u i n t 3 2 _ t ; t y p e d e f U in t_ 1 6 u i n t l 6 _ t ; t y p e d e f U in t_ 8 u i n t 8 t ;
t y p e d e f I n t_ 3 2 i n t 3 2 _ t ; t y p e d e f I n t _ l 6 i n t l 6 _ t ; t y p e d e f I n t _ 8 i n t 8 _ t ;
# e n d if
使 用 s t d i n t .h 来编写嵌入式的软件和固件，你的代码会是整洁且可移植的。 当夕犬，我们应该让所有的软件都独立于处理器，但这并不是所有固件都可以做到的。 
下面这段代码使用了特殊的c 扩展来访问微处理器的配件，这样做的目的很可能就 是为了使用这个配件。这个函数的作用就是输出一行"hi"到串口。（该例子来自于 
一个真实项目。）
!1!
v o id s a y _ h i ()
{
IE = ObllOOOOOO; SBUFO = (0 x 6 8 )； w h ile (T I_ 0 == ° )； T I_0 = 0;
SBUFO = (0 x 6 9 )； w h ile (T I 0 === 0 )/
'll架构整洁之道
TI_O = 0;
SBUFO = (0 x 0 a )； w h ile (TI 0 == 0 ) ； TI 0 - 0;
SBUFO = (OxOd)； w h ile (T I_ 0 == 0 ) ； T I_0 = 0;
IE = ObllOlOOOO;
}
这个小函数屮存在大量的问题。首先，你注意到的可能就是0bllOOOOOO。二 进制表示法的确很酷，但C 语言支持它吗？并不支持。另外还有一些冋题也与C语
言的扩展有关。
IE：设置中断比特位。
SBUFO:串口输出缓冲区。
T I_ 0 :串口传输区空中断。读取到1表明缓冲区为空。
这些名字大写的变量实际上都是用来访问微处理器的内置部件的。如果我们需 
要控制中断并且输出字符，就必须使用这些部件，它们也确实很方便—— 但这不是 
C 代码。
在整洁的嵌入式架构中，我们会将这些用于设备访问的寄存器访问集中在一起， 
并将其限制在固件层中。这样一来，任何需要知道这些寄存器值的代码都必须成为 
固件代码，与硬件实现绑定。一旦这些代码与处理器实现强绑定，那么在处理器稳 
宦工作之前它们是无法工作的，并且在需要将其迁移到一个新处理器上时也会遇到 
麻烦。
如果我们真的需要使用这种微处理器，固件就必须将这类底层函数隔离成处理 
器抽象层(PAL) , 这样一来,使用PAL的固件代码就可以在目标平台之外被测试 
了。 —泌
234■ -------- ――—
■ ------- 第 29章 整洁的嵌入式架构
操作系统是实现细节
统使用了某种实时操作系统（RTOS） , 或者某种嵌 入 式 的 叽 或 Windo胃 为了延长代码的牛命周期，我们必须将操作系统也定义为实现细节， 
让代码避 
免与操作系统层产生依赖。
软件通过操作系统来访问运行环境服务。操作系统是将软件与固件隔离的那一 
层 （见图29.5） , 直接使用操作系统服务可能会带来问题。例如，如果更换了 RTOS 
操作系统厂商，授权费用提高，或者质量下降怎么办？如果需求发生变化，RTOS 
无法满足怎么办？很多代码都需要变动，不仅要更改语法适应新操作系统A P I,很 
有可能需要重新适应新操作系统的语义与原语。
图2 9 , 添加操作系统层 （° s A L ,如图29.6所示），将软件 蠹 嚮 囂 蠶 ; 込 驚 常 w z 而在另-些情况下，则 需 要 将 几 个 :； 那有绅苦。如果我们能让自 
如果你有过迁移R T ? 煮 常 爲 操 作 系 统 ，我们就只需要写-个兼容以 
己的软件依赖于O S A L ,血 、心 —架构整洁之道
鸚曲黑:m F 霊g 叫
O S A L
H A L
固件
硬件
图29.6：操作系统抽象层
当然，我们可能会担心代码膨胀的问题。但是，其实上面这种分层已经将因为 
使用操作系统所带来的重复性代码隔离开了，因此这种重复不一定会带来很大的额 
外负担。而且，如果我们定义了 OSAL,还可以让自己的应用共享一种公用结构。 
比如采用一套标准的消息传递机制，这样每个线程就不用自己定义一个并行模型了。
另外，OSAL还可以帮助高价值的应用程序实现在目标平台、目标操作系统之 
外进行测试。一个由整洁的嵌入式架构所构建出来的软件是可以在目标操作系统之 
外被测试的。设计良好的OSAL会为这种目标环境外的测试提供支撑点。
面向接口编程与可替代性
增加HAL和 OSAL之外，我们还可以
除"土嵌入式系统的主要分层（指软件、操作系统、固件、硬件这四层）之中 
也应该 应用本书中提到的其他设计原 
则。宓些设计原则可以帮助我们按功能模块、接口编程以及可替代性来划分系统。
。当模块之间能以接口形式交第29章 整洁的嵌入式架构
很多读者应该都写过能 
只嗖我们的p r i n t f 与
互时，我们就可以将-个服务替换成另外•个服务,，例如， 
在某个目标机器上运行的、小型的自定义的戸士亡f 函数 标准的p r in t f 函数接I I -致,它们就可以互相替换 目前的普适规则之一就是用头丈件来充当接I j的定（ 做的话，就需要小心控制头文件中的内容，尽量确保头文件中只包括函数声明，以 
及函数所需要的结构体名字和常量。
然而;如果真的要这样
另外，不要在定义接口的头文件中包含只有具体实现代码才需要的数据结构、 
常量以及类型定义（typedef） 。这不仅仅是架构是否整洁的问题，而是这样做可能 会导致意外的依赖关系。总之，我们必须控制好实现细节的可见性，因为这些实现 
细节是肯定会变化的。关注实现细节的代码越少，它们所需的变更就越少。
由整洁的嵌入式架构所构建的系统应该在每一个分层中都是可测试的，因为它 
的模块之间采用接口通信，每一个接口都为平台之外的测试提供了替换点。
DRY条件性编译命令
另一个经常被忽视的可替代换性规则的实际案例是嵌入式C/C++程序对不同平 
台和操作系统的处理方式。这些程序经常会用条件性编译命令来根据不同的平台启 
用和禁用某一段代码。例如，我曾经遇到过# ifd ef BOARD_V2这条语句在一个 电信应用程序中出现了几千次的情况。
•很显然，这种代码的重复违背了“不要重复自己（DRY）”原则- 如果 
BOARD V 2只出现一次，这当然不是什么问题，而如果出现了 6000次，那就非常严 
重了。石这类条件性编译语句在嵌入式编程中非常常见，有什么好的解决方案吗？
使用硬件抽象层如何？这样的话，硬 件 类 型 警 是 律 鬻 二 算 那 
而且，如果系统中使用的是HAL所 提 供 的 一 系 歹 豐 豊 囂 豊 驚 句 ’那 
么我们就可以用链接器，或者某种运行时加载器来将轨件与硬件相” 「
1
请参考Hunt和Thomas合著的呢Pragmatic M ）即 （i川 皿 乩
237架构整洁之道
本章小结
嵌入式编程人员应该多学习一些非嵌入式系统的编程经验。 
入式编程工作，相信你一定会从本章的建议中得到很多启发。
为了让我们的产品能长期地保持健康，请别让你的代码都变成固件。如果一个 
系统的代码只能在目标硬件上测试，那么它的开发过程会变得非常艰难。总之，为 
产品的长期健康着想而采用一套整洁的嵌入式架构是很有必要的。